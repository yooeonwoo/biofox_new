{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement User Detail API",
        "description": "Create the API endpoint to fetch detailed user information including relationship history, recent activity, and statistics.",
        "details": "Create a GET endpoint at `/api/users/[userId]/route.ts` that retrieves comprehensive user data from Supabase.\n\nImplementation steps:\n1. Create the API route file with proper Next.js 14 structure\n2. Implement authentication middleware to verify admin access\n3. Call the Supabase RPC function `get_user_detailed_info`\n4. If the RPC function doesn't exist yet, create it with the following SQL:\n```sql\nCREATE OR REPLACE FUNCTION get_user_detailed_info(user_id UUID)\nRETURNS JSON AS $$\nDECLARE\n  user_data JSON;\n  relationship_data JSON;\n  activity_data JSON;\n  crm_stats JSON;\n  sales_stats JSON;\nBEGIN\n  -- Get basic user info\n  SELECT json_build_object(\n    'id', p.id,\n    'name', p.name,\n    'email', p.email,\n    'role', p.role,\n    'status', p.status,\n    'shop_name', p.shop_name,\n    'region', p.region,\n    'commission_rate', p.commission_rate,\n    'created_at', p.created_at\n  ) INTO user_data\n  FROM profiles p\n  WHERE p.id = user_id;\n\n  -- Get relationship history\n  SELECT json_agg(json_build_object(\n    'id', sr.id,\n    'parent_id', sr.parent_id,\n    'parent_name', pp.name,\n    'parent_role', pp.role,\n    'started_at', sr.created_at,\n    'ended_at', sr.ended_at,\n    'is_active', sr.is_active\n  )) INTO relationship_data\n  FROM shop_relationships sr\n  JOIN profiles pp ON sr.parent_id = pp.id\n  WHERE sr.child_id = user_id\n  ORDER BY sr.created_at DESC;\n\n  -- Get recent activity\n  SELECT json_build_object(\n    'orders', (SELECT json_agg(json_build_object(\n      'id', o.id,\n      'order_date', o.created_at,\n      'total_amount', o.total_amount,\n      'commission_amount', o.commission_amount\n    ))\n    FROM orders o\n    WHERE o.user_id = user_id\n    ORDER BY o.created_at DESC\n    LIMIT 5),\n    'clinical_cases', (SELECT json_agg(json_build_object(\n      'id', cc.id,\n      'name', cc.name,\n      'status', cc.status,\n      'created_at', cc.created_at\n    ))\n    FROM clinical_cases cc\n    WHERE cc.user_id = user_id\n    ORDER BY cc.created_at DESC\n    LIMIT 5)\n  ) INTO activity_data;\n\n  -- Get CRM stats\n  SELECT json_build_object(\n    'total_cards', COUNT(c.id),\n    'total_stages', COUNT(DISTINCT c.stage),\n    'completed_stages', COUNT(c.id) FILTER (WHERE c.status = 'completed'),\n    'completion_rate', CASE WHEN COUNT(c.id) > 0 THEN \n      ROUND((COUNT(c.id) FILTER (WHERE c.status = 'completed')::numeric / COUNT(c.id)) * 100, 2)\n      ELSE 0 END\n  ) INTO crm_stats\n  FROM crm_cards c\n  WHERE c.user_id = user_id;\n\n  -- Get sales stats\n  SELECT json_build_object(\n    'total_sales', COALESCE(SUM(o.total_amount), 0),\n    'total_commission', COALESCE(SUM(o.commission_amount), 0)\n  ) INTO sales_stats\n  FROM orders o\n  WHERE o.user_id = user_id;\n\n  -- Combine all data\n  RETURN json_build_object(\n    'data', json_build_object(\n      'user', user_data,\n      'relationship_history', COALESCE(relationship_data, '[]'::json),\n      'recent_activity', COALESCE(activity_data, '{}'::json),\n      'crm_stats', COALESCE(crm_stats, '{}'::json),\n      'sales_stats', COALESCE(sales_stats, '{}'::json)\n    )\n  );\nEND;\n$$ LANGUAGE plpgsql;\n```\n5. Implement error handling for cases where user doesn't exist\n6. Ensure response matches the required format in the PRD\n7. Add appropriate caching headers for performance",
        "testStrategy": "1. Unit test the API endpoint with Jest:\n   - Test successful retrieval with mock Supabase responses\n   - Test error handling for non-existent users\n   - Test authentication failure scenarios\n\n2. Integration test with actual Supabase:\n   - Verify all data sections are correctly populated\n   - Verify performance meets the 1-second response time requirement\n   - Test with different user roles and data scenarios\n\n3. Manual testing:\n   - Verify the UserDetailModal correctly displays all sections\n   - Check that relationship history is properly formatted\n   - Validate that statistics are calculated correctly",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement User Edit API",
        "description": "Create the API endpoint to update user information with proper validation and error handling.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Implement the PUT method in `/api/users/[userId]/route.ts` to handle user information updates and the DELETE method for user deletion.\n\nImplementation steps:\n1. Add the PUT handler to the existing route file\n2. Implement authentication and authorization checks\n3. Validate incoming request data against the schema:\n```typescript\nconst updateUserSchema = z.object({\n  name: z.string().optional(),\n  role: z.enum(['admin', 'kol', 'ol', 'shop_owner']).optional(),\n  status: z.enum(['pending', 'approved', 'rejected']).optional(),\n  shop_name: z.string().optional(),\n  region: z.string().optional(),\n  commission_rate: z.number().min(0).max(100).optional()\n});\n```\n4. Sanitize inputs to prevent SQL injection and XSS attacks\n5. Update the user record in Supabase:\n```typescript\nconst { error } = await supabase\n  .from('profiles')\n  .update(validatedData)\n  .eq('id', userId);\n```\n6. If the role is changed, handle any necessary side effects (e.g., updating relationships)\n7. Return appropriate success or error responses\n8. Log the change for audit purposes\n9. Implement DELETE method with proper cascading and data integrity\n10. Ensure audit logging for user deletion\n11. Add validation for UUID format and user existence checks\n12. Set approved_at and approved_by automatically when user status changes to approved",
        "testStrategy": "1. Unit test the API endpoint:\n   - Test successful updates with various field combinations\n   - Test validation errors for invalid inputs\n   - Test authorization checks\n   - Test successful deletion\n   - Test prevention of self-deletion\n\n2. Integration test with Supabase:\n   - Verify updates are correctly persisted\n   - Test role change scenarios and their side effects\n   - Verify audit logging works correctly\n   - Verify all related data is properly deleted\n   - Test with the new Supabase project `cezxkgmzlkbjqataogtd`\n\n3. Security testing:\n   - Test with malicious inputs to verify sanitization\n   - Verify only authorized users can update profiles\n   - Test with invalid user IDs\n   - Verify admin-only access for certain operations\n\n4. UI testing:\n   - Verify the edit form in the UI correctly submits to this API\n   - Check that validation errors are properly displayed\n   - Verify success messages appear after successful updates\n   - Test deletion confirmation and feedback",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "Implement PUT method with Zod validation schema",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "Add XSS prevention for input data",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "Implement UUID format validation and user existence checks",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "",
            "description": "Add admin authorization and user permission validation",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "",
            "description": "Implement audit logging for role changes",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "",
            "description": "Add automatic approved_at and approved_by setting",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "",
            "description": "Implement detailed error handling and response messages",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "",
            "description": "Add debugging information for development environment",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "",
            "description": "Implement DELETE method with self-deletion prevention",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "",
            "description": "Add audit logging for user deletion",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "",
            "description": "Connect API with new Supabase project `cezxkgmzlkbjqataogtd`",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "",
            "description": "Document the implemented endpoints for team reference",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement User Delete API",
        "description": "Create the API endpoint to delete users and their associated data with proper cascading and data integrity.",
        "details": "Implement the DELETE method in `/api/users/[userId]/route.ts` to handle user deletion with proper cascading.\n\nImplementation steps:\n1. Add the DELETE handler to the existing route file\n2. Implement strict authentication and authorization checks (admin only)\n3. Create a transaction to ensure data integrity during deletion\n4. Delete related data in the correct order to respect foreign key constraints:\n```typescript\nconst { error } = await supabase.rpc('delete_user_with_related_data', { user_id: userId });\n```\n5. Create the RPC function in Supabase if it doesn't exist:\n```sql\nCREATE OR REPLACE FUNCTION delete_user_with_related_data(user_id UUID)\nRETURNS VOID AS $$\nBEGIN\n  -- Delete orders\n  DELETE FROM orders WHERE user_id = user_id;\n  \n  -- Delete clinical cases\n  DELETE FROM clinical_cases WHERE user_id = user_id;\n  \n  -- Delete CRM cards\n  DELETE FROM crm_cards WHERE user_id = user_id;\n  \n  -- Delete shop relationships\n  DELETE FROM shop_relationships WHERE child_id = user_id OR parent_id = user_id;\n  \n  -- Delete user profile\n  DELETE FROM profiles WHERE id = user_id;\n  \n  -- Delete auth user (if using Supabase Auth)\n  DELETE FROM auth.users WHERE id = user_id;\nEND;\n$$ LANGUAGE plpgsql;\n```\n6. Implement proper error handling and rollback on failure\n7. Return appropriate success or error responses\n8. Add audit logging for security compliance",
        "testStrategy": "1. Unit test the API endpoint:\n   - Test successful deletion\n   - Test authorization failures\n   - Test error handling\n\n2. Integration test with Supabase:\n   - Verify all related data is properly deleted\n   - Test transaction rollback on failure\n   - Verify audit logs are created\n\n3. Data integrity testing:\n   - Verify no orphaned records remain after deletion\n   - Test with users that have complex relationships\n   - Verify Supabase Auth user is properly removed\n\n4. UI testing:\n   - Verify delete confirmation dialog works correctly\n   - Check that user list updates after deletion\n   - Verify proper success/error messages are displayed",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Bulk Action API",
        "description": "Create the API endpoint to perform bulk operations on multiple users including approval, rejection, role changes, and deletion.",
        "details": "Create a new API endpoint at `/api/users/bulk-action/route.ts` to handle various bulk operations on multiple users.\n\nImplementation steps:\n1. Create the new API route file with POST method\n2. Implement strict authentication and authorization checks\n3. Validate the incoming request data:\n```typescript\nconst bulkActionSchema = z.object({\n  user_ids: z.array(z.string().uuid()).min(1),\n  action: z.enum(['approve', 'reject', 'change_role', 'delete']),\n  data: z.object({\n    role: z.enum(['admin', 'kol', 'ol', 'shop_owner']).optional()\n  }).optional()\n});\n```\n4. Create the Supabase RPC function if it doesn't exist:\n```sql\nCREATE OR REPLACE FUNCTION bulk_update_users(\n  user_ids UUID[],\n  action_type TEXT,\n  action_data JSONB DEFAULT '{}'::jsonb\n)\nRETURNS JSON AS $$\nDECLARE\n  successful_ids UUID[] := '{}';\n  failed_records JSON[] := '{}';\n  current_id UUID;\n  error_message TEXT;\n  affected_count INTEGER := 0;\nBEGIN\n  FOREACH current_id IN ARRAY user_ids\n  LOOP\n    BEGIN\n      CASE action_type\n        WHEN 'approve' THEN\n          UPDATE profiles SET status = 'approved' WHERE id = current_id;\n          \n        WHEN 'reject' THEN\n          UPDATE profiles SET status = 'rejected' WHERE id = current_id;\n          \n        WHEN 'change_role' THEN\n          IF action_data->>'role' IS NULL THEN\n            RAISE EXCEPTION 'Role is required for change_role action';\n          END IF;\n          UPDATE profiles SET role = action_data->>'role' WHERE id = current_id;\n          \n        WHEN 'delete' THEN\n          PERFORM delete_user_with_related_data(current_id);\n          \n        ELSE\n          RAISE EXCEPTION 'Unknown action type: %', action_type;\n      END CASE;\n      \n      affected_count := affected_count + 1;\n      successful_ids := array_append(successful_ids, current_id);\n      \n    EXCEPTION WHEN OTHERS THEN\n      error_message := SQLERRM;\n      failed_records := array_append(failed_records, \n        json_build_object('id', current_id, 'error', error_message));\n    END;\n  END LOOP;\n  \n  RETURN json_build_object(\n    'affected', affected_count,\n    'results', json_build_object(\n      'successful', successful_ids,\n      'failed', failed_records\n    )\n  );\nEND;\n$$ LANGUAGE plpgsql;\n```\n5. Call the RPC function from the API:\n```typescript\nconst { data, error } = await supabase.rpc('bulk_update_users', {\n  user_ids: validatedData.user_ids,\n  action_type: validatedData.action,\n  action_data: validatedData.data || {}\n});\n```\n6. Implement proper error handling and response formatting\n7. Add transaction support for atomicity\n8. Add audit logging for each affected user",
        "testStrategy": "1. Unit test the API endpoint:\n   - Test each action type with valid inputs\n   - Test validation errors\n   - Test authorization checks\n\n2. Integration test with Supabase:\n   - Verify each bulk action works correctly\n   - Test with mixed success/failure scenarios\n   - Verify the response format matches requirements\n\n3. Performance testing:\n   - Test with varying numbers of users (10, 50, 100)\n   - Verify response time scales appropriately\n   - Test concurrent bulk operations\n\n4. UI testing:\n   - Verify bulk action UI correctly calls this API\n   - Check that progress indicators work\n   - Verify success/error summaries are displayed correctly",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement User Add Modal Component",
        "description": "Create a new modal component for adding users with form validation, email verification, and Supabase Auth integration.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "Create a new React component at `components/biofox-admin/users/UserAddModal.tsx` to handle user creation.\n\nImplementation steps:\n1. Create the new component with proper TypeScript typing:\n```typescript\ninterface UserAddModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onSuccess: () => void;\n}\n\nconst UserAddModal: React.FC<UserAddModalProps> = ({ isOpen, onClose, onSuccess }) => {\n  // Implementation here\n};\n```\n2. Implement a form with the following fields:\n   - Email (required, with validation)\n   - Name (required)\n   - Role (required, select from options)\n   - Shop name (required for shop_owner role)\n   - Region (optional)\n   - Commission rate (optional, numeric with min/max)\n\n3. Add email duplication check:\n```typescript\nconst checkEmailExists = async (email: string) => {\n  const { data, error } = await supabase\n    .from('profiles')\n    .select('id')\n    .eq('email', email)\n    .maybeSingle();\n  \n  return !!data;\n};\n```\n\n4. Implement conditional field validation based on selected role\n\n5. Add form submission handler that:\n   - Creates user profile in Supabase\n   - Sends invitation email via Supabase Auth\n   - Handles success/error states\n\n6. Create a new API endpoint at `/api/users/route.ts` with POST method to handle user creation:\n```typescript\nexport async function POST(req: Request) {\n  const { email, name, role, shop_name, region, commission_rate } = await req.json();\n  \n  // Validate admin access\n  const session = await getServerSession();\n  if (!session || session.user.role !== 'admin') {\n    return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 403 });\n  }\n  \n  // Check if email exists\n  const { data: existingUser } = await supabase\n    .from('profiles')\n    .select('id')\n    .eq('email', email)\n    .maybeSingle();\n    \n  if (existingUser) {\n    return new Response(JSON.stringify({ error: 'Email already exists' }), { status: 400 });\n  }\n  \n  // Create user in Auth\n  const { data: authUser, error: authError } = await supabase.auth.admin.inviteUserByEmail(email);\n  \n  if (authError) {\n    return new Response(JSON.stringify({ error: authError.message }), { status: 500 });\n  }\n  \n  // Create profile\n  const { error: profileError } = await supabase\n    .from('profiles')\n    .insert({\n      id: authUser.user.id,\n      email,\n      name,\n      role,\n      shop_name,\n      region,\n      commission_rate,\n      status: 'pending'\n    });\n    \n  if (profileError) {\n    return new Response(JSON.stringify({ error: profileError.message }), { status: 500 });\n  }\n  \n  return new Response(JSON.stringify({ success: true }), { status: 201 });\n}\n```\n\n7. Add proper error handling and user feedback\n8. Implement loading states and success confirmation",
        "testStrategy": "1. Unit test the component:\n   - Test form validation for all fields\n   - Test conditional validation based on role\n   - Test email duplication check\n\n2. Integration test with API:\n   - Test successful user creation\n   - Test error handling scenarios\n   - Verify Supabase Auth invitation is sent\n\n3. UI testing:\n   - Verify form layout and responsiveness\n   - Test form submission and feedback\n   - Verify modal opens and closes correctly\n\n4. End-to-end testing:\n   - Complete the full user creation flow\n   - Verify created user appears in the user list\n   - Test the invitation email flow",
        "subtasks": [
          {
            "id": 1,
            "title": "API POST Endpoint Implementation",
            "description": "Created `/api/users/route.ts` with complete implementation including Zod validation schema, Supabase Auth integration, XSS prevention, email duplication check, and comprehensive error handling.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "UserAddModal Component Implementation",
            "description": "Implemented UserAddModal component using React Hook Form with Zod resolver, including all required fields (email, name, role, shop name, region, commission rate), conditional field display based on role (hiding commission rate for admin), real-time form validation with error display, and loading state management.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "User Management Page Integration",
            "description": "Integrated UserAddModal into the user management page, connected 'Add User' button to open the modal, implemented automatic list refresh on successful user addition, and added Toast notifications for user feedback.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Type System Completion",
            "description": "Added User-related types to types/biofox-admin/index.ts including UserFilters, PaginationState, and BulkActionRequest types to ensure complete type safety.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Security and UX Features",
            "description": "Implemented admin permission verification, email duplication checking with real-time validation, automatic audit logging, invitation email confirmation, and user-friendly error messages.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Supabase Project Integration",
            "description": "Ensured all functionality is properly integrated with the new Supabase project 'cezxkgmzlkbjqataogtd'.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Excel Export API",
        "description": "Create the API endpoint to export user data to Excel/CSV format with proper filtering and Korean character encoding support.",
        "details": "Create a new API endpoint at `/api/users/export/route.ts` to handle exporting user data to CSV format.\n\nImplementation steps:\n1. Create the new API route file with GET method\n2. Implement authentication and authorization checks\n3. Parse and apply filter parameters from the request query:\n```typescript\nconst { searchTerm, role, status, region, sortBy, sortOrder } = req.query;\n```\n4. Fetch filtered user data from Supabase:\n```typescript\nlet query = supabase.from('profiles').select('*');\n\nif (searchTerm) {\n  query = query.textSearch('name,email,shop_name', searchTerm);\n}\n\nif (role) {\n  query = query.eq('role', role);\n}\n\n// Apply other filters...\n\nif (sortBy && sortOrder) {\n  query = query.order(sortBy, { ascending: sortOrder === 'asc' });\n}\n\nconst { data, error } = await query;\n```\n5. Transform the data to CSV format using a library like `csv-stringify`:\n```typescript\nimport { stringify } from 'csv-stringify/sync';\n\nconst headers = [\n  'ID', '이름', '이메일', '역할', '상태', '상점명', '지역', '수수료율', '가입일'\n];\n\nconst rows = data.map(user => [\n  user.id,\n  user.name,\n  user.email,\n  translateRole(user.role), // Helper to translate role to Korean\n  translateStatus(user.status), // Helper to translate status to Korean\n  user.shop_name || '',\n  user.region || '',\n  user.commission_rate ? `${user.commission_rate}%` : '',\n  new Date(user.created_at).toLocaleDateString('ko-KR')\n]);\n\nconst csvContent = stringify([headers, ...rows]);\n```\n6. Add UTF-8 BOM for Korean character support:\n```typescript\nconst BOM = '\\uFEFF';\nconst csvWithBOM = BOM + csvContent;\n```\n7. Set appropriate headers for file download:\n```typescript\nreturn new Response(csvWithBOM, {\n  headers: {\n    'Content-Type': 'text/csv;charset=utf-8',\n    'Content-Disposition': `attachment; filename=\"users_export_${new Date().toISOString().split('T')[0]}.csv\"`\n  }\n});\n```\n8. Add error handling for failed queries\n9. Implement caching headers to prevent duplicate downloads",
        "testStrategy": "1. Unit test the API endpoint:\n   - Test with various filter combinations\n   - Test authorization checks\n   - Test error handling\n\n2. Integration test with Supabase:\n   - Verify data is correctly fetched and filtered\n   - Test with large datasets for performance\n   - Verify all user fields are correctly exported\n\n3. File format testing:\n   - Verify CSV structure is correct\n   - Test Korean character encoding (UTF-8 with BOM)\n   - Verify the file can be opened in Excel\n\n4. UI testing:\n   - Verify export button correctly triggers download\n   - Test that current filters are applied to export\n   - Verify download progress indicators",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-18T10:54:20.972Z",
      "updated": "2025-07-21T05:44:49.687Z",
      "description": "Tasks for master context"
    }
  }
}