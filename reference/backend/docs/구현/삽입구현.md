# CSV 데이터 Supabase 삽입 구현 계획

테이블데이터삽입순서.md의 지침에 따라 CSV 데이터를 Supabase 테이블에 삽입하는 구현 계획입니다.

## 1. 구현 접근 방식

구현은 Supabase Javascript SDK를 사용하여 Node.js 스크립트로 작성할 예정입니다. CSV 파일 처리를 위해 `csv-parser` 라이브러리를 사용하고, 각 테이블의 데이터를 순차적으로 삽입하는 방식으로 진행합니다.

### 필요한 패키지
```
npm install @supabase/supabase-js csv-parser fs dotenv
```

### 기본 설정 파일 (`.env`)
```
SUPABASE_URL=https://lobjronqhjkvyecweyeu.supabase.co
SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxvYmpyb25xaGprdnllY3dleWV1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDIxMjExMzcsImV4cCI6MjA1NzY5NzEzN30.NF-V9CdU2S9zfCUVzh8o1OgQWgW8ie4HK31guRM1rNs
```

## 2. 데이터 삽입 순서 및 처리 방법

### 2.1 기본 스크립트 구조

각 테이블별로 별도의 함수를 만들어 처리하고, 이를 순차적으로 실행합니다. 각 함수는:

1. CSV 파일 읽기
2. 데이터 전처리 (필요한 경우 날짜 변환, ID 처리, NULL 처리 등)
3. Supabase에 데이터 삽입
4. 결과 로깅

### 2.2 공통 유틸리티 함수

```javascript
// 날짜 형식 변환 (YYYY/MM/DD -> YYYY-MM-DD)
function convertDate(dateStr) {
  if (!dateStr) return null;
  return dateStr.replace(/\//g, '-');
}

// 비어있는 필드 처리
function handleEmptyField(value, defaultValue = null) {
  if (value === undefined || value === null || value === '') {
    return defaultValue;
  }
  return value;
}

// 커미션 비율 처리 (예: "100%" -> 100.00)
function convertCommissionRate(rateStr) {
  if (!rateStr) return null;
  return parseFloat(rateStr.replace('%', ''));
}
```

## 2.3 Supabase RPC 함수 생성 구현

특정 테이블(product_categories, regions 등)에서는 ID를 직접 지정하고 시퀀스를 재설정해야 합니다. 이를 위해 Supabase에서 다음과 같은 RPC 함수를 SQL Editor에서 생성하고 사용해야 합니다.

### ID 직접 삽입을 위한 RPC 함수

```sql
-- ID 직접 삽입 함수 생성
CREATE OR REPLACE FUNCTION insert_with_id(
  table_name text,
  record jsonb,
  id_value integer
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  EXECUTE format(
    'INSERT INTO %I SELECT * FROM json_populate_record(null::%I, $1) WHERE id = $2',
    table_name,
    table_name
  ) USING record, id_value;
END;
$$;
```

### 시퀀스 재설정을 위한 RPC 함수

```sql
-- 시퀀스 재설정 함수 생성
CREATE OR REPLACE FUNCTION restart_sequence(
  table_name text,
  seq_value integer
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  seq_name text;
BEGIN
  -- 테이블의 시퀀스 이름 가져오기
  SELECT pg_get_serial_sequence(table_name, 'id') INTO seq_name;
  
  -- 시퀀스 재설정
  IF seq_name IS NOT NULL THEN
    EXECUTE format('ALTER SEQUENCE %s RESTART WITH %s', seq_name, seq_value);
  END IF;
END;
$$;
```

### RPC 함수 생성을 위한 스크립트 (init-rpc.js)

```javascript
// init-rpc.js: Supabase에 RPC 함수를 생성하는 스크립트
require('dotenv').config();
const { createClient } = require('@supabase/supabase-js');

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_ANON_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

async function createRpcFunctions() {
  try {
    console.log('Creating RPC functions...');
    
    // ID 직접 삽입 함수 생성
    const insertWithIdQuery = `
      CREATE OR REPLACE FUNCTION insert_with_id(
        table_name text,
        record jsonb,
        id_value integer
      )
      RETURNS void
      LANGUAGE plpgsql
      AS $$
      BEGIN
        EXECUTE format(
          'INSERT INTO %I SELECT * FROM json_populate_record(null::%I, $1) WHERE id = $2',
          table_name,
          table_name
        ) USING record, id_value;
      END;
      $$;
    `;
    
    // 시퀀스 재설정 함수 생성
    const restartSequenceQuery = `
      CREATE OR REPLACE FUNCTION restart_sequence(
        table_name text,
        seq_value integer
      )
      RETURNS void
      LANGUAGE plpgsql
      AS $$
      DECLARE
        seq_name text;
      BEGIN
        -- 테이블의 시퀀스 이름 가져오기
        SELECT pg_get_serial_sequence(table_name, 'id') INTO seq_name;
        
        -- 시퀀스 재설정
        IF seq_name IS NOT NULL THEN
          EXECUTE format('ALTER SEQUENCE %s RESTART WITH %s', seq_name, seq_value);
        END IF;
      END;
      $$;
    `;
    
    // 함수 생성 실행
    const { error: insertWithIdError } = await supabase.rpc('exec_sql', { sql: insertWithIdQuery });
    if (insertWithIdError) {
      console.error('Error creating insert_with_id function:', insertWithIdError);
      
      // 대안: SQL 에디터에서 직접 실행하기 위한 안내
      console.log('\nPlease execute the following SQL in the Supabase SQL Editor:');
      console.log(insertWithIdQuery);
    } else {
      console.log('Successfully created insert_with_id function.');
    }
    
    const { error: restartSequenceError } = await supabase.rpc('exec_sql', { sql: restartSequenceQuery });
    if (restartSequenceError) {
      console.error('Error creating restart_sequence function:', restartSequenceError);
      
      // 대안: SQL 에디터에서 직접 실행하기 위한 안내
      console.log('\nPlease execute the following SQL in the Supabase SQL Editor:');
      console.log(restartSequenceQuery);
    } else {
      console.log('Successfully created restart_sequence function.');
    }
    
    console.log('RPC function creation process completed.');
  } catch (error) {
    console.error('Error in RPC function creation process:', error);
    console.log('\nAlternative: Please use the Supabase SQL Editor to create these functions manually.');
  }
}

// 실행
createRpcFunctions();
```

### 대안: SQL 에디터에서 직접 실행

Supabase의 SQL 에디터에서 위의 SQL 쿼리를 직접 실행할 수도 있습니다:

1. Supabase 대시보드에 로그인
2. SQL 에디터 메뉴 선택
3. 새 쿼리 생성 버튼 클릭
4. 위의 SQL 쿼리 붙여넣기 및 실행

이렇게 하면 시퀀스를 재설정하거나 ID를 직접 지정하여 데이터를 삽입할 수 있는 RPC 함수가 생성됩니다.

## 3. 테이블별 구현 계획

### 3.1 roles 테이블

```javascript
async function insertRoles() {
  console.log('Inserting roles...');
  const rolesData = [];
  
  // CSV 파일 읽기
  fs.createReadStream('../csv/migration - roles.csv')
    .pipe(csv())
    .on('data', (row) => {
      // id 필드는 비어있으므로 auto-increment
      const role = {
        name: row.name,
        description: handleEmptyField(row.description),
        created_at: handleEmptyField(row.created_at, new Date().toISOString()),
        updated_at: handleEmptyField(row.updated_at, new Date().toISOString())
      };
      rolesData.push(role);
    })
    .on('end', async () => {
      try {
        const { data, error } = await supabase
          .from('roles')
          .insert(rolesData)
          .select();
          
        if (error) throw error;
        console.log(`Successfully inserted ${data.length} roles`);
        return data;
      } catch (error) {
        console.error('Error inserting roles:', error);
      }
    });
}
```

### 3.2 permissions 테이블

```javascript
async function insertPermissions() {
  console.log('Inserting permissions...');
  const permissionsData = [];
  
  fs.createReadStream('../csv/migration - permissions.csv')
    .pipe(csv())
    .on('data', (row) => {
      const permission = {
        name: row.name,
        description: handleEmptyField(row.description),
        resource: row.resource,
        action: row.action,
        created_at: handleEmptyField(row.created_at, new Date().toISOString()),
        updated_at: handleEmptyField(row.updated_at, new Date().toISOString())
      };
      permissionsData.push(permission);
    })
    .on('end', async () => {
      try {
        const { data, error } = await supabase
          .from('permissions')
          .insert(permissionsData)
          .select();
          
        if (error) throw error;
        console.log(`Successfully inserted ${data.length} permissions`);
        return data;
      } catch (error) {
        console.error('Error inserting permissions:', error);
      }
    });
}
```

### 3.3 role_permissions 테이블 (목업 데이터)

```javascript
async function insertRolePermissions() {
  console.log('Inserting role permissions...');
  
  // 간단한 목업 데이터: Admin 역할에 모든 권한 부여
  try {
    // 먼저 역할과 권한 데이터 가져오기
    const { data: roles, error: rolesError } = await supabase
      .from('roles')
      .select('id, name');
    
    if (rolesError) throw rolesError;
    
    const { data: permissions, error: permissionsError } = await supabase
      .from('permissions')
      .select('id');
      
    if (permissionsError) throw permissionsError;
    
    // Admin 역할 찾기
    const adminRole = roles.find(role => role.name === 'Admin');
    if (!adminRole) {
      console.log('Admin role not found');
      return;
    }
    
    // 모든 권한에 대해 role_permissions 생성
    const rolePermissionsData = permissions.map(permission => ({
      role_id: adminRole.id,
      permission_id: permission.id,
      created_at: new Date().toISOString()
    }));
    
    const { data, error } = await supabase
      .from('role_permissions')
      .insert(rolePermissionsData);
      
    if (error) throw error;
    console.log(`Successfully inserted ${rolePermissionsData.length} role permissions for Admin`);
    
    // 다른 역할에 대한 권한 설정 (필요한 경우)
    
  } catch (error) {
    console.error('Error inserting role permissions:', error);
  }
}
```

### 3.4 users 테이블

```javascript
async function insertUsers() {
  console.log('Inserting users...');
  const usersData = [];
  let userCount = 0;
  
  fs.createReadStream('../csv/migration - users.csv')
    .pipe(csv())
    .on('data', (row) => {
      // 이메일이 비어있는 SHOP 유저에 대한 처리
      const email = handleEmptyField(row.email, `placeholder${userCount}@shop.com`);
      
      const user = {
        email: email,
        password_hash: handleEmptyField(row.password_hash, 'TEMPORARY_HASH'), // NOT NULL 제약조건 대응
        full_name: row.full_name,
        role: row.role,
        profile_image: handleEmptyField(row.profile_image),
        phone: handleEmptyField(row.phone),
        created_at: handleEmptyField(row.created_at, new Date().toISOString()),
        updated_at: handleEmptyField(row.updated_at, new Date().toISOString())
      };
      usersData.push(user);
      userCount++;
    })
    .on('end', async () => {
      try {
        const { data, error } = await supabase
          .from('users')
          .insert(usersData)
          .select();
          
        if (error) throw error;
        console.log(`Successfully inserted ${data.length} users`);
        return data;
      } catch (error) {
        console.error('Error inserting users:', error);
      }
    });
}
```

### 3.5 user_roles 테이블 (목업 데이터)

```javascript
async function insertUserRoles() {
  console.log('Inserting user roles...');
  
  try {
    // 사용자와 역할 데이터 가져오기
    const { data: users, error: usersError } = await supabase
      .from('users')
      .select('id, role');
    
    if (usersError) throw usersError;
    
    const { data: roles, error: rolesError } = await supabase
      .from('roles')
      .select('id, name');
    
    if (rolesError) throw rolesError;
    
    // 각 사용자의 role 문자열을 기반으로 role_id 매핑
    const userRolesData = [];
    
    users.forEach(user => {
      const matchingRole = roles.find(role => role.name === user.role);
      if (matchingRole) {
        userRolesData.push({
          user_id: user.id,
          role_id: matchingRole.id,
          created_at: new Date().toISOString()
        });
      }
    });
    
    if (userRolesData.length > 0) {
      const { data, error } = await supabase
        .from('user_roles')
        .insert(userRolesData);
        
      if (error) throw error;
      console.log(`Successfully inserted ${userRolesData.length} user roles`);
      return data;
    }
  } catch (error) {
    console.error('Error inserting user roles:', error);
  }
}
```

### 3.6 lead_sources 테이블

```javascript
async function insertLeadSources() {
  console.log('Inserting lead sources...');
  const leadSourcesData = [];
  
  fs.createReadStream('../csv/migration - lead_sources.csv')
    .pipe(csv())
    .on('data', (row) => {
      const leadSource = {
        name: row.name,
        description: handleEmptyField(row.description),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      leadSourcesData.push(leadSource);
    })
    .on('end', async () => {
      try {
        const { data, error } = await supabase
          .from('lead_sources')
          .insert(leadSourcesData)
          .select();
          
        if (error) throw error;
        console.log(`Successfully inserted ${data.length} lead sources`);
        return data;
      } catch (error) {
        console.error('Error inserting lead sources:', error);
      }
    });
}
```

### 3.7 lead_statuses 테이블

```javascript
async function insertLeadStatuses() {
  console.log('Inserting lead statuses...');
  const leadStatusesData = [];
  
  fs.createReadStream('../csv/migration - lead_statuses.csv')
    .pipe(csv())
    .on('data', (row) => {
      const leadStatus = {
        name: row.name,
        description: handleEmptyField(row.description),
        order: parseInt(row.order),
        color: handleEmptyField(row.color),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      leadStatusesData.push(leadStatus);
    })
    .on('end', async () => {
      try {
        const { data, error } = await supabase
          .from('lead_statuses')
          .insert(leadStatusesData)
          .select();
          
        if (error) throw error;
        console.log(`Successfully inserted ${data.length} lead statuses`);
        return data;
      } catch (error) {
        console.error('Error inserting lead statuses:', error);
      }
    });
}
```

### 3.8 product_categories 테이블

```javascript
async function insertProductCategories() {
  console.log('Inserting product categories...');
  
  try {
    // 먼저 루트 카테고리 생성
    const rootCategory = {
      id: 1,
      name: 'ROOT',
      code: 'root',
      parent_id: null,
      description: '최상위 카테고리',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
    
    // id=1로 직접 삽입하기 위해 identity를 무시
    const { error: rootError } = await supabase.rpc('insert_with_id', { 
      table_name: 'product_categories',
      record: rootCategory,
      id_value: 1
    });
    
    if (rootError) {
      // identity override RPC 함수가 없다면 일반 삽입 시도
      const { error: fallbackError } = await supabase
        .from('product_categories')
        .insert(rootCategory);
      
      if (fallbackError) throw fallbackError;
    }
    
    console.log('Successfully inserted root product category');
    
    // 그런 다음 CSV에서 하위 카테고리 추가
    const categoriesData = [];
    
    fs.createReadStream('../csv/migration - product_categories.csv')
      .pipe(csv())
      .on('data', (row) => {
        // id=1을 부모로 하는 하위 카테고리
        const category = {
          name: row.name,
          code: handleEmptyField(row.code),
          parent_id: parseInt(handleEmptyField(row.parent_id, 1)),
          description: handleEmptyField(row.description),
          created_at: handleEmptyField(row.created_at, new Date().toISOString()),
          updated_at: handleEmptyField(row.updated_at, new Date().toISOString())
        };
        categoriesData.push(category);
      })
      .on('end', async () => {
        try {
          const { data, error } = await supabase
            .from('product_categories')
            .insert(categoriesData)
            .select();
            
          if (error) throw error;
          console.log(`Successfully inserted ${data.length} product categories`);
          
          // 시퀀스 재설정 (id=2부터 시작)
          const { error: seqError } = await supabase.rpc('restart_sequence', {
            table_name: 'product_categories',
            seq_value: categoriesData.length + 2
          });
          
          if (seqError) console.error('Error resetting sequence:', seqError);
          
          return data;
        } catch (error) {
          console.error('Error inserting product categories:', error);
        }
      });
  } catch (error) {
    console.error('Error in product categories insertion process:', error);
  }
}
```

### 3.9 regions 테이블

```javascript
async function insertRegions() {
  console.log('Inserting regions...');
  const regionsData = [];
  
  fs.createReadStream('../csv/migration - regions.csv')
    .pipe(csv())
    .on('data', (row) => {
      // CSV에 id가 이미 지정되어 있음
      const region = {
        id: parseInt(row.id),
        name: row.name,
        code: handleEmptyField(row.code),
        parent_id: handleEmptyField(row.parent_id) ? parseInt(row.parent_id) : null,
        level: parseInt(row.level),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      regionsData.push(region);
    })
    .on('end', async () => {
      try {
        // identity를 무시하고 id 컬럼을 직접 사용
        for (const region of regionsData) {
          const { error } = await supabase.rpc('insert_with_id', { 
            table_name: 'regions',
            record: region,
            id_value: region.id
          });
          
          if (error) {
            // RPC 함수가 없다면 일반 삽입으로 시도 (id 열은 무시될 수 있음)
            const { error: fallbackError } = await supabase
              .from('regions')
              .insert(region);
            
            if (fallbackError) throw fallbackError;
          }
        }
        
        console.log(`Successfully inserted ${regionsData.length} regions`);
        
        // 시퀀스 재설정
        const maxId = Math.max(...regionsData.map(r => r.id)) + 1;
        const { error: seqError } = await supabase.rpc('restart_sequence', {
          table_name: 'regions',
          seq_value: maxId
        });
        
        if (seqError) console.error('Error resetting sequence:', seqError);
        
      } catch (error) {
        console.error('Error inserting regions:', error);
      }
    });
}
```

### 3.10 settings 테이블 (목업 데이터)

```javascript
async function insertSettings() {
  console.log('Inserting settings...');
  
  const settingsData = [
    {
      category: 'system',
      key: 'company_name',
      value: 'Example Company',
      description: '회사명',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    },
    {
      category: 'email',
      key: 'notification_enabled',
      value: 'true',
      description: '이메일 알림 활성화 여부',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    }
  ];
  
  try {
    const { data, error } = await supabase
      .from('settings')
      .insert(settingsData)
      .select();
      
    if (error) throw error;
    console.log(`Successfully inserted ${data.length} settings`);
    return data;
  } catch (error) {
    console.error('Error inserting settings:', error);
  }
}
```

### 3.11 leads 테이블

```javascript
async function insertLeads() {
  console.log('Inserting leads...');
  const leadsData = [];
  
  fs.createReadStream('../csv/migration - leads.csv')
    .pipe(csv())
    .on('data', (row) => {
      const lead = {
        name: row.name,
        email: handleEmptyField(row.email),
        phone: handleEmptyField(row.phone),
        status_id: handleEmptyField(row.status_id) ? parseInt(row.status_id) : 1, // 기본값: 신규(1)
        source_id: handleEmptyField(row.source_id) ? parseInt(row.source_id) : 1, // 기본값: 메타 광고(1)
        assigned_to: handleEmptyField(row.assigned_to) ? parseInt(row.assigned_to) : null,
        notes: handleEmptyField(row.notes),
        created_at: handleEmptyField(row.created_at) ? convertDate(row.created_at) : new Date().toISOString(),
        updated_at: handleEmptyField(row.updated_at) ? convertDate(row.updated_at) : new Date().toISOString(),
        seminar_reservation_date: handleEmptyField(row.seminar_reservation_date),
        cafe_id: handleEmptyField(row.cafe_id)
      };
      leadsData.push(lead);
    })
    .on('end', async () => {
      try {
        // 대량의 데이터를 여러 번에 나눠서 삽입
        const batchSize = 100;
        for (let i = 0; i < leadsData.length; i += batchSize) {
          const batch = leadsData.slice(i, i + batchSize);
          const { data, error } = await supabase
            .from('leads')
            .insert(batch);
            
          if (error) throw error;
          console.log(`Successfully inserted leads batch ${i/batchSize + 1}`);
        }
        
        console.log(`Successfully inserted all ${leadsData.length} leads`);
      } catch (error) {
        console.error('Error inserting leads:', error);
      }
    });
}
```

### 3.12 shops 테이블

```javascript
async function insertShops() {
  console.log('Inserting shops...');
  const shopsData = [];
  
  fs.createReadStream('../csv/migration - shops.csv')
    .pipe(csv())
    .on('data', (row) => {
      const shop = {
        name: row.name,
        owner_name: handleEmptyField(row.owner_name),
        address: handleEmptyField(row.address),
        phone: handleEmptyField(row.phone),
        email: handleEmptyField(row.email),
        business_number: handleEmptyField(row.business_number),
        status: handleEmptyField(row.status, 'active'),
        manager_id: handleEmptyField(row.manager_id) ? parseInt(row.manager_id) : null,
        region_id: handleEmptyField(row.region_id) ? parseInt(row.region_id) : null,
        created_at: handleEmptyField(row.created_at) ? convertDate(row.created_at) : new Date().toISOString(),
        updated_at: handleEmptyField(row.updated_at) ? convertDate(row.updated_at) : new Date().toISOString(),
        converted_from_lead_id: null, // CSV에 없음
        kol_id: null // 나중에 업데이트
      };
      shopsData.push(shop);
    })
    .on('end', async () => {
      try {
        const { data, error } = await supabase
          .from('shops')
          .insert(shopsData)
          .select();
          
        if (error) throw error;
        console.log(`Successfully inserted ${data.length} shops`);
        return data;
      } catch (error) {
        console.error('Error inserting shops:', error);
      }
    });
}
```

### 3.13 products 테이블

```javascript
async function insertProducts() {
  console.log('Inserting products...');
  const productsData = [];
  
  fs.createReadStream('../csv/migration - products.csv')
    .pipe(csv())
    .on('data', (row) => {
      const product = {
        name: row.name,
        code: row.code,
        category_id: handleEmptyField(row.category_id) ? parseInt(row.category_id) : null,
        description: handleEmptyField(row.description),
        price: handleEmptyField(row.price) ? parseFloat(row.price) : null,
        commission_rate: handleEmptyField(row.commission_rate) ? convertCommissionRate(row.commission_rate) : null,
        created_at: handleEmptyField(row.created_at) ? convertDate(row.created_at) : new Date().toISOString(),
        updated_at: handleEmptyField(row.updated_at) ? convertDate(row.updated_at) : new Date().toISOString()
      };
      productsData.push(product);
    })
    .on('end', async () => {
      try {
        const { data, error } = await supabase
          .from('products')
          .insert(productsData)
          .select();
          
        if (error) throw error;
        console.log(`Successfully inserted ${data.length} products`);
        return data;
      } catch (error) {
        console.error('Error inserting products:', error);
      }
    });
}
```

## 4. 추가 테이블 목업 데이터

### 4.1 kols 테이블

```javascript
async function insertKols() {
  console.log('Inserting kols...');
  
  try {
    // KOL 역할을 가진 사용자 찾기
    const { data: users, error: usersError } = await supabase
      .from('users')
      .select('id')
      .eq('role', 'KOL');
    
    if (usersError) throw usersError;
    
    if (users && users.length > 0) {
      const kolsData = users.map(user => ({
        user_id: user.id,
        specialty: '피부케어',
        bio: '전문 KOL',
        contract_start_date: new Date().toISOString(),
        contract_end_date: new Date(new Date().setFullYear(new Date().getFullYear() + 1)).toISOString(),
        commission_rate: 10.00,
        status: 'active',
        bank_account: '예시 계좌번호',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        affiliated_shop_id: null,
        device_sales_count: 0,
        is_shop: false,
        parent_kol_id: null
      }));
      
      const { data, error } = await supabase
        .from('kols')
        .insert(kolsData)
        .select();
        
      if (error) throw error;
      console.log(`Successfully inserted ${data.length} kols`);
      
      // SHOP 연동을 위한 나중 업데이트 작업 준비
      // (별도 함수로 구현 예정)
      
      return data;
    }
  } catch (error) {
    console.error('Error inserting kols:', error);
  }
}
```

### 4.2 customers 테이블 (목업 데이터)

```javascript
async function insertCustomers() {
  console.log('Inserting customers...');
  
  try {
    // 기존 데이터에서 leads와 shops 가져오기
    const { data: leads, error: leadsError } = await supabase
      .from('leads')
      .select('id, name, email, phone')
      .limit(10);
    
    if (leadsError) throw leadsError;
    
    const { data: shops, error: shopsError } = await supabase
      .from('shops')
      .select('id')
      .limit(5);
    
    if (shopsError) throw shopsError;
    
    const { data: users, error: usersError } = await supabase
      .from('users')
      .select('id')
      .eq('role', 'Sales Rep')
      .limit(3);
    
    if (usersError) throw usersError;
    
    // 목업 고객 데이터 생성
    const customersData = [];
    
    if (leads && leads.length > 0) {
      leads.forEach((lead, index) => {
        customersData.push({
          lead_id: lead.id,
          name: lead.name,
          email: lead.email,
          phone: lead.phone,
          address: '서울시 강남구',
          birth_date: null,
          gender: index % 2 === 0 ? '여성' : '남성',
          shop_id: shops && shops.length > 0 ? shops[index % shops.length].id : null,
          assigned_to: users && users.length > 0 ? users[index % users.length].id : null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });
      });
      
      const { data, error } = await supabase
        .from('customers')
        .insert(customersData)
        .select();
        
      if (error) throw error;
      console.log(`Successfully inserted ${data.length} customers`);
      return data;
    }
  } catch (error) {
    console.error('Error inserting customers:', error);
  }
}
```

### 4.3 양방향 참조 관계 처리 - Shop과 KOL 연동

```javascript
async function updateShopKolRelationships() {
  console.log('Updating Shop-KOL relationships...');
  
  try {
    // 1. 먼저 KOL 데이터와 Shop 데이터 가져오기
    const { data: kols, error: kolsError } = await supabase
      .from('kols')
      .select('id, user_id');
    
    if (kolsError) throw kolsError;
    
    const { data: shops, error: shopsError } = await supabase
      .from('shops')
      .select('id, owner_name');
    
    if (shopsError) throw shopsError;
    
    // 2. users 테이블에서 KOL 관련 사용자 정보 가져오기
    const { data: users, error: usersError } = await supabase
      .from('users')
      .select('id, full_name, role')
      .eq('role', 'KOL');
    
    if (usersError) throw usersError;
    
    // 3. Shop과 KOL 매핑을 위한 준비
    // 여기서는 이름 매칭을 시도합니다. 
    // 실제 시스템에서는 다른 매핑 방식을 사용할 수 있습니다.
    const updates = [];
    
    // 각 KOL에 대해 매칭되는 Shop 찾기
    for (const kol of kols) {
      const user = users.find(u => u.id === kol.user_id);
      if (!user) continue;
      
      // 사용자 이름으로 매칭되는 shop 찾기
      // 비즈니스 로직에 따라 조정 필요
      const matchingShop = shops.find(shop => 
        user.full_name === shop.owner_name || 
        shop.owner_name.includes(user.full_name)
      );
      
      if (matchingShop) {
        // 양방향 관계 업데이트
        // 1. kol.affiliated_shop_id 업데이트
        const { error: kolUpdateError } = await supabase
          .from('kols')
          .update({ affiliated_shop_id: matchingShop.id })
          .eq('id', kol.id);
        
        if (kolUpdateError) {
          console.error(`Error updating KOL ${kol.id} with shop ${matchingShop.id}:`, kolUpdateError);
          continue;
        }
        
        // 2. shop.kol_id 업데이트
        const { error: shopUpdateError } = await supabase
          .from('shops')
          .update({ kol_id: kol.id })
          .eq('id', matchingShop.id);
        
        if (shopUpdateError) {
          console.error(`Error updating Shop ${matchingShop.id} with KOL ${kol.id}:`, shopUpdateError);
          continue;
        }
        
        updates.push({ kol_id: kol.id, shop_id: matchingShop.id });
      }
    }
    
    console.log(`Successfully updated ${updates.length} Shop-KOL relationships`);
    
    // 4. KOL 계층 구조 설정 - 부모/자식 관계 (예시: 상위 10%의 KOL을 부모로 설정)
    if (kols.length > 0) {
      const parentCount = Math.max(1, Math.floor(kols.length * 0.1)); // 상위 10%를 부모로
      const parentKols = kols.slice(0, parentCount);
      const childKols = kols.slice(parentCount);
      
      for (let i = 0; i < childKols.length; i++) {
        const parentIndex = i % parentCount;
        const parentKol = parentKols[parentIndex];
        
        // 부모 KOL 설정
        const { error: parentUpdateError } = await supabase
          .from('kols')
          .update({ parent_kol_id: parentKol.id })
          .eq('id', childKols[i].id);
        
        if (parentUpdateError) {
          console.error(`Error setting parent KOL for KOL ${childKols[i].id}:`, parentUpdateError);
        }
      }
      
      console.log(`Successfully set up hierarchical relationships for ${childKols.length} KOLs`);
    }
    
    return updates;
  } catch (error) {
    console.error('Error updating Shop-KOL relationships:', error);
  }
}
```

## 5. 통합 실행 계획

```javascript
async function migrateData() {
  try {
    console.log('Starting data migration...');
    
    // 1. 독립적인 기본 테이블
    await insertRoles();
    await insertPermissions();
    await insertRolePermissions();
    
    // 2. 사용자 관련
    await insertUsers();
    await insertUserRoles();
    
    // 3. 업무 관련 기본 데이터
    await insertLeadSources();
    await insertLeadStatuses();
    await insertProductCategories();
    await insertRegions();
    await insertSettings();
    
    // 4. 핵심 비즈니스 데이터
    await insertLeads();
    await insertShops();
    await insertProducts();
    
    // 5. 추가 데이터 (KOL, 고객 등)
    await insertKols();
    await insertCustomers();
    
    // 6. 샵-KOL 연동 업데이트 (양방향 참조 처리)
    await updateShopKolRelationships();
    
    console.log('Data migration completed successfully!');
  } catch (error) {
    console.error('Error during migration:', error);
  }
}

// 실행
migrateData();
```

## 6. 추가적으로 구현할 사항

1. Supabase에서 시퀀스 재설정 및 ID 직접 삽입을 위한 RPC 함수 생성
2. 대용량 CSV 파일(leads.csv)의 효율적인 처리 최적화
3. 양방향 참조 관계(shops-kols) 처리를 위한 업데이트 함수
4. 오류 처리 및 롤백 메커니즘 구현
5. 로깅 및 진행 상황 모니터링 개선

이 구현 계획은 다음 단계에서 실제 코드로 작성하여 테스트하고 최적화할 예정입니다.
