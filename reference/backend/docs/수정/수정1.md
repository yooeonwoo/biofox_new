아래는 **전체 테이블 구조**와 **테이블 간 FK/참조관계**를 모두 고려하여, **어떤 순서로 데이터를 INSERT**해야 에러 없이 깔끔하게 들어가는지 정리한 **권장 순서**입니다.  
만약 특정 테이블의 CSV가 없더라도, **목업(MOCK) 데이터를 몇 건씩**이라도 만들어 **부모 테이블 → 자식 테이블** 순으로 채워 넣어야 FK violation을 피할 수 있습니다.  
(특히 **양방향 FK**나 **자기 자신을 참조**하는 구조는 INSERT 시점에 한쪽을 `NULL`로 두었다가, 나중에 UPDATE로 다시 매핑하는 방식이 필요할 수도 있습니다.)

---

## 1. 전체 테이블 간 주요 FK 관계 요약

1. **roles** / **permissions**: 서로 참조 없음(독립).  
2. **role_permissions**: `role_id → roles.id`, `permission_id → permissions.id`  
3. **users**: 참조 없음(스키마상으로는 FK가 없으며, 단 `users.role`은 문자열)  
4. **user_roles**: `user_id → users.id`, `role_id → roles.id`  

5. **lead_sources**, **lead_statuses**, **settings**: 참조 없음(독립)  
6. **product_categories**: 자기 자신을 참조(`parent_id → product_categories.id`)  
7. **regions**: 자기 자신을 참조(`parent_id → regions.id`)  

8. **leads**:  
   - `source_id → lead_sources.id`  
   - `status_id → lead_statuses.id`  
   - `assigned_to → users.id` (담당자)

9. **shops**:  
   - `converted_from_lead_id → leads.id` (선택/NULL)  
   - `manager_id → users.id` (매니저)  
   - `region_id → regions.id`  
   - **`kol_id → kols.id`** (양방향 FK 문제 있음)  

10. **kols**:  
    - `user_id → users.id`  
    - `affiliated_shop_id → shops.id` (선택/NULL)  
    - `parent_kol_id → kols.id` (자기 자신 참조)  
    - (양방향 FK 주의: `shops.kol_id` ↔ `kols.affiliated_shop_id`)

11. **customers**:  
    - `lead_id → leads.id` (전환된 리드인 경우)  
    - `shop_id → shops.id` (선택)  
    - `assigned_to → users.id`  

12. **products**:  
    - `category_id → product_categories.id`  

13. **sales**:  
    - `product_id → products.id`  
    - `customer_id → customers.id`  
    - `shop_id → shops.id`  
    - `sales_rep_id → users.id`  
    - `kol_id → kols.id`  

14. **commissions**:  
    - `sale_id → sales.id`  

15. **sales_activities**:  
    - `user_id → users.id`  
    - `shop_id → shops.id`  
    - `lead_id → leads.id`  
    - `customer_id → customers.id`  

16. **seminars**: (테이블 구조에 없지만, 예시로 `organizer_id → users.id` 같은 FK가 있을 수 있다고 가정. 만약 필요하다면 목업 FK 설정)  

17. **seminar_attendees**:  
    - `seminar_id → seminars.id`  
    - `lead_id → leads.id`  

18. **tasks**:  
    - `assigned_to → users.id`  
    - `assigned_by → users.id`  
    - `lead_id → leads.id`  
    - `customer_id → customers.id`  
    - `seminar_id → seminars.id`  

19. **notifications**:  
    - `user_id → users.id`  
    - `lead_id`, `customer_id`, `seminar_id`, `task_id` 등 각 FK

20. **activities**:  
    - `user_id → users.id`  
    - `lead_id → leads.id`  
    - `customer_id → customers.id`  
    - `seminar_id → seminars.id`  
    - (unique 제약: `(user_id, lead_id, activity_type)`)

21. **(기타)** `commissions.recipient_id`와 `recipient_type`(kols, sales_rep 등) 관계는 로직에 따라 다를 수 있으나, FK로 직접 연결되진 않음.

---

## 2. **권장 데이터 입력 순서** (최상위 → 하위)

아래 순서는 **부모(참조 대상) 테이블**부터 넣고, 그 테이블을 참조하는 **자식(참조자) 테이블**로 점차 내려가는 방식입니다.  
중간중간 **양방향 참조**(shops.kol_id ↔ kols.affiliated_shop_id)나 **자기 자신을 참조**(product_categories, regions, kols.parent_kol_id)가 있을 경우의 처리 방법도 표기하였습니다.

1. **roles** (독립)  
2. **permissions** (독립)  
3. **role_permissions** (`role_id → roles.id`, `permission_id → permissions.id`)

4. **users** (독립, PK만 존재)  
5. **user_roles** (`user_id → users.id`, `role_id → roles.id`)

6. **lead_sources** (독립)  
7. **lead_statuses** (독립)  
8. **product_categories**  
   - 자기 자신 참조(`parent_id`). **루트 카테고리(예: id=1, name='ROOT')**부터 INSERT → 하위(자식) 카테고리 순  
9. **regions**  
   - 자기 자신 참조(`parent_id`). 마찬가지로 **상위(루트) 지역** → 하위(시/군/구) → 더 하위 동/면/읍 …  
10. **settings** (독립)

11. **leads**  
    - FK: `source_id → lead_sources.id`, `status_id → lead_statuses.id`, `assigned_to → users.id`

12. **shops**  
    - FK: `converted_from_lead_id → leads.id`(옵션), `manager_id → users.id`, `region_id → regions.id`  
    - **`kol_id`**는 **나중**에 업데이트 (초기에 `NULL`로 INSERT)  
      - (이유: `kols`가 아직 안 들어갔으므로 바로 참조 불가)

13. **kols**  
    - FK: `user_id → users.id`, `affiliated_shop_id → shops.id`(옵션)  
    - 자기 자신 참조(`parent_kol_id → kols.id`), 상위 KOL부터 → 하위 KOL  
    - `shops.kol_id` ↔ `kols.affiliated_shop_id`가 양방향인 경우:
      - **INSERT** 시점: `affiliated_shop_id`(kols) 쪽은 `shops.id`가 이미 있으므로 OK  
      - **`shops.kol_id`**는 아직 없으므로, **`NULL`**로 shops INSERT → kols 생성 후 → **UPDATE** `shops SET kol_id = ? WHERE id = ?`로 채운다.

14. **products**  
    - FK: `category_id → product_categories.id`

15. **customers**  
    - FK: `lead_id → leads.id` (전환된 리드일 경우)  
    - `shop_id → shops.id` (옵션)  
    - `assigned_to → users.id`

16. **sales**  
    - FK: `product_id → products.id`  
    - `customer_id → customers.id`  
    - `shop_id → shops.id`  
    - `sales_rep_id → users.id`  
    - `kol_id → kols.id`

17. **commissions**  
    - FK: `sale_id → sales.id`

18. **sales_activities**  
    - FK: `user_id → users.id`, `shop_id → shops.id`, `lead_id → leads.id`, `customer_id → customers.id`

19. **seminars** (만약 있다면; 예: `organizer_id → users.id`)  
    - CSV가 없더라도 사용한다면 **mock data**로 1~2건 넣기

20. **seminar_attendees**  
    - FK: `seminar_id → seminars.id`, `lead_id → leads.id`

21. **tasks**  
    - FK: `assigned_to, assigned_by → users.id`  
    - `lead_id, customer_id, seminar_id` 등 필요시 참조

22. **notifications**  
    - FK: `user_id → users.id`, `lead_id, customer_id, seminar_id, task_id` 등 필요 시 참조

23. **activities**  
    - FK: `user_id → users.id`, `lead_id → leads.id`, `customer_id → customers.id`, `seminar_id → seminars.id`  
    - (unique 제약) `(user_id, lead_id, activity_type)` 중복 주의

---

## 3. **양방향/자기참조 테이블** 처리 팁

1. **`shops` ↔ `kols`**  
   - 서로 FK가 걸려 있으면, 테이블 생성 단계에서 한쪽 FK를 미리 빼놓고(`kol_id`) 만들었다가 이후 `ALTER TABLE`로 추가하는 방법도 있음.  
   - **데이터 INSERT 시**에는 보통  
     1) `shops`에 `kol_id = NULL`로 먼저 INSERT  
     2) `kols`를 INSERT (`affiliated_shop_id`로 shops.id 참조)  
     3) 마지막에 `UPDATE shops SET kol_id = kols.id`  
2. **`product_categories`**  
   - `parent_id → product_categories.id`  
   - **루트 카테고리**부터 → 순차적으로 하위 카테고리를 INSERT
3. **`regions`**  
   - `parent_id → regions.id`  
   - 최상위(대한민국) → 광역시도 → 시군구 → 동/면/읍… 순
4. **`kols`**  
   - `parent_kol_id → kols.id`  
   - 상위 KOL(루트)이 먼저 → 하위(자식) kol

---

## 4. **CSV가 없는 테이블**은 **목업(MOCK) 데이터**로 최소 1~2건이라도 만들기

만약 CSV가 없는 테이블(예: `seminars`, `activities`, `commissions` 등)에 대해서도 **FK**가 연결되어 있으면,  
- 예: `sales → commissions`, `seminars → seminar_attendees`  
- 이 FK를 만족시키려면 **해당 부모 테이블**에 데이터가 필요하므로,  
  - 예: `seminars`에 mock data 1건 (seminar_id=1, organizer_id=어떤 user_id)  
  - 그 후 `seminar_attendees`에 (seminar_id=1, lead_id=some_lead)  
- 이런 식으로 **부모부터 최소한 1건**이라도 INSERT해주어야 “자식” 데이터가 들어갈 수 있습니다.

---

## 5. 예시 시나리오 요약

1. **roles** 테이블(`Admin`, `Sales Manager`, etc.) / **permissions** 테이블(`leads.create`, `leads.read` 등)  
2. **role_permissions**로 역할-권한 매핑  
3. **users**에 실제 유저(관리자, 영업사원 등)들 INSERT  
4. **user_roles**로 각 `users.id` ↔ `roles.id` 매핑  
5. **lead_sources** / **lead_statuses** / **settings** (독립 테이블들)  
6. **product_categories**:  
   - `id=1` 루트(“ROOT”) → 하위(“마이크로젯”, “바이오폭스” 등)  
7. **regions**:  
   - 최상위(“대한민국”, id=1) → “서울특별시”(id=2) → “강남구”(id=19) → “삼성동”(id=37) … 순  
8. **leads** (source_id, status_id, assigned_to)  
9. **shops**  
   - `converted_from_lead_id`(선택), `manager_id`, `region_id`는 참조  
   - `kol_id`는 **NULL**  
10. **kols**  
   - `user_id`, `affiliated_shop_id`  
   - `parent_kol_id` 있으면 상위부터  
   - (이후 `shops.kol_id` UPDATE)  
11. **products** (category_id)  
12. **customers** (lead_id, shop_id, assigned_to)  
13. **sales** (product_id, customer_id, shop_id, sales_rep_id, kol_id)  
14. **commissions** (sale_id)  
15. **sales_activities** (user_id, shop_id, lead_id, customer_id)  
16. **seminars** (사용한다면)  
17. **seminar_attendees** (seminar_id, lead_id)  
18. **tasks** (assigned_to, assigned_by, lead_id, customer_id, seminar_id)  
19. **notifications** (user_id, lead_id, customer_id, seminar_id, task_id)  
20. **activities** (user_id, lead_id, customer_id, seminar_id)

---

## 6. 마무리 요점

1. **부모(참조대상) 테이블**부터 데이터를 넣고, 자식(참조자) 테이블을 나중에 넣어야 **FK violation**을 피할 수 있음.  
2. **양방향 FK**(shops.kol_id ↔ kols.affiliated_shop_id)는 보통 한쪽 컬럼을 **NULL**로 먼저 INSERT 후, 마지막에 UPDATE.  
3. **자기 자신을 참조**하는 계층형 테이블(product_categories, regions, kols)도 **상위(루트)부터** 순서대로 INSERT.  
4. CSV가 없는 테이블도, **FK로 연결된 경우**에는 **목업데이터**(부모부터 1~2건)라도 추가해줘야 참조관계가 성립.  
5. 최종 INSERT 순서는 **(roles, permissions) → role_permissions → users → user_roles → lead_sources → lead_statuses → product_categories → regions → settings → leads → shops(NULL kol_id) → kols → (UPDATE shops.kol_id) → products → customers → sales → commissions → sales_activities → seminars(목업?) → seminar_attendees → tasks → notifications → activities** 로 마무리.

이 과정을 따르면, “CSV가 없더라도” 전체 DB 구조상 **계층/참조 문제**를 해결하면서 데이터를 안전하게 마이그레이션할 수 있습니다.  