<?xml version="1.0" encoding="UTF-8"?>
<code>
  <file path="db/migrations/sales-commission.ts">
/**
 * 매출수당계산 데이터베이스 마이그레이션 스크립트
 * 
 * 다음 테이블을 생성합니다:
 * - monthly_sales: KOL별, 전문점별 월별 매출 및 수당 관리
 * - product_sales_ratios: 전문점별 제품 매출 비율 관리
 * - kol_hierarchy: KOL 계층 구조 관리
 * - kol_monthly_summary: KOL 월별 매출/수당 요약 데이터
 */

import { drizzle } from 'drizzle-orm/postgres-js';
import { migrate } from 'drizzle-orm/postgres-js/migrator';
import postgres from 'postgres';
import dotenv from 'dotenv';

dotenv.config();

// 환경변수에서 데이터베이스 연결 정보 가져오기
const connectionString = process.env.DATABASE_URL || '';

if (!connectionString) {
  console.error('DATABASE_URL 환경변수가 설정되지 않았습니다.');
  process.exit(1);
}

// 마이그레이션 실행 함수
async function runMigration() {
  console.log('매출수당계산 테이블 마이그레이션을 시작합니다...');
  
  try {
    // Postgres 연결 설정
    const sql = postgres(connectionString, { max: 1 });
    
    // Drizzle 인스턴스 생성
    const db = drizzle(sql);
    
    // 마이그레이션 실행
    await migrate(db, { migrationsFolder: 'drizzle' });
    
    console.log('마이그레이션이 성공적으로 완료되었습니다.');
    
    // 연결 종료
    await sql.end();
  } catch (error) {
    console.error('마이그레이션 중 오류가 발생했습니다:', error);
    process.exit(1);
  }
}

// 스크립트 실행
runMigration();
</file>
  <file path="db/schema.ts.backup">
import { pgTable, serial, varchar, timestamp, integer, boolean, foreignKey, text, decimal } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

// 사용자 테이블
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  clerkId: varchar("clerk_id", { length: 255 }).notNull().unique(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  name: varchar("name", { length: 255 }),
  role: varchar("role", { length: 50 }).notNull().default("kol"), // 본사관리자, kol
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 사용자 관계 정의
export const usersRelations = relations(users, ({ one, many }) => ({
  kol: one(kols, {
    fields: [users.id],
    references: [kols.userId],
  }),
  notifications: many(notifications),
}));

// KOL 테이블
export const kols = pgTable("kols", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  name: varchar("name", { length: 255 }).notNull(),
  shopName: varchar("shop_name", { length: 255 }).notNull(),
  region: varchar("region", { length: 100 }),
  smartPlaceLink: varchar("smart_place_link", { length: 500 }),
  status: varchar("status", { length: 50 }).default("active").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// KOL 관계 정의
export const kolsRelations = relations(kols, ({ one, many }) => ({
  user: one(users, {
    fields: [kols.userId],
    references: [users.id],
  }),
  shops: many(shops),
  commissions: many(commissions),
  monthlySummaries: many(kolMonthlySummary),
  monthlySales: many(monthlySales),
  childKols: many(kolHierarchy, { relationName: "parentKols" }),
  parentKols: many(kolHierarchy, { relationName: "childKols" }),
}));

// 전문점 테이블
export const shops = pgTable("shops", {
  id: serial("id").primaryKey(),
  kolId: integer("kol_id").references(() => kols.id).notNull(),
  ownerName: varchar("owner_name", { length: 255 }).notNull(),
  region: varchar("region", { length: 100 }),
  smartPlaceLink: varchar("smart_place_link", { length: 500 }),
  status: varchar("status", { length: 50 }).default("active").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 전문점 관계 정의
export const shopsRelations = relations(shops, ({ one, many }) => ({
  kol: one(kols, {
    fields: [shops.kolId],
    references: [kols.id],
  }),
  orders: many(orders),
  monthlySales: many(monthlySales),
  productRatios: many(productSalesRatios),
}));

// 제품 테이블
export const products = pgTable("products", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  price: integer("price").notNull(),
  isDevice: boolean("is_device").default(false).notNull(), // 기기(true) 또는 일반 제품(false)
  description: text("description"),
  image: varchar("image", { length: 500 }),
  category: varchar("category", { length: 100 }),
  status: varchar("status", { length: 50 }).default("active").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 제품 관계 정의
export const productsRelations = relations(products, ({ many }) => ({
  orderItems: many(orderItems),
  salesRatios: many(productSalesRatios),
}));

// 주문 테이블
export const orders = pgTable("orders", {
  id: serial("id").primaryKey(),
  orderNumber: varchar("order_number", { length: 255 }).notNull().unique(),
  shopId: integer("shop_id").references(() => shops.id).notNull(),
  totalAmount: integer("total_amount").notNull(),
  status: varchar("status", { length: 50 }).default("pending").notNull(),
  orderDate: timestamp("order_date").defaultNow().notNull(),
  paymentMethod: varchar("payment_method", { length: 100 }),
  paymentStatus: varchar("payment_status", { length: 50 }).default("pending").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 주문 관계 정의
export const ordersRelations = relations(orders, ({ one, many }) => ({
  shop: one(shops, {
    fields: [orders.shopId],
    references: [shops.id],
  }),
  orderItems: many(orderItems),
  commission: one(commissions, {
    fields: [orders.id],
    references: [commissions.orderId],
  }),
}));

// 주문 상세 테이블
export const orderItems = pgTable("order_items", {
  id: serial("id").primaryKey(),
  orderId: integer("order_id").references(() => orders.id).notNull(),
  productId: integer("product_id").references(() => products.id).notNull(),
  quantity: integer("quantity").notNull(),
  price: integer("price").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 주문 상세 관계 정의
export const orderItemsRelations = relations(orderItems, ({ one }) => ({
  order: one(orders, {
    fields: [orderItems.orderId],
    references: [orders.id],
  }),
  product: one(products, {
    fields: [orderItems.productId],
    references: [products.id],
  }),
}));

// 수당 테이블
export const commissions = pgTable("commissions", {
  id: serial("id").primaryKey(),
  kolId: integer("kol_id").references(() => kols.id).notNull(),
  orderId: integer("order_id").references(() => orders.id).notNull(),
  amount: integer("amount").notNull(),
  settled: boolean("settled").default(false).notNull(),
  settledDate: timestamp("settled_date"),
  settledNote: varchar("settled_note", { length: 500 }),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 수당 관계 정의
export const commissionsRelations = relations(commissions, ({ one }) => ({
  kol: one(kols, {
    fields: [commissions.kolId],
    references: [kols.id],
  }),
  order: one(orders, {
    fields: [commissions.orderId],
    references: [orders.id],
  }),
}));

// 알림 테이블
export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  title: varchar("title", { length: 255 }).notNull(),
  content: varchar("content", { length: 1000 }).notNull(),
  read: boolean("read").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 알림 관계 정의
export const notificationsRelations = relations(notifications, ({ one }) => ({
  user: one(users, {
    fields: [notifications.userId],
    references: [users.id],
  }),
}));

// 월별 매출 및 수당 관리 테이블
export const monthlySales = pgTable("monthly_sales", {
  id: serial("id").primaryKey(),
  kolId: integer("kol_id").references(() => kols.id).notNull(),
  shopId: integer("shop_id").references(() => shops.id).notNull(),
  yearMonth: varchar("year_month", { length: 7 }).notNull(), // YYYY-MM 형식
  productSales: integer("product_sales").notNull().default(0), // 제품 매출 합계 (기기 제외)
  deviceSales: integer("device_sales").notNull().default(0), // 기기 매출 합계
  totalSales: integer("total_sales").notNull().default(0), // 총 매출 (제품+기기)
  commission: integer("commission").notNull().default(0), // 수당 합계
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 월별 매출 관계 정의
export const monthlySalesRelations = relations(monthlySales, ({ one }) => ({
  kol: one(kols, {
    fields: [monthlySales.kolId],
    references: [kols.id],
  }),
  shop: one(shops, {
    fields: [monthlySales.shopId],
    references: [shops.id],
  }),
}));

// 제품별 매출 비율 테이블
export const productSalesRatios = pgTable("product_sales_ratios", {
  id: serial("id").primaryKey(),
  shopId: integer("shop_id").references(() => shops.id).notNull(),
  kolId: integer("kol_id").references(() => kols.id).notNull(),
  yearMonth: varchar("year_month", { length: 7 }).notNull(), // YYYY-MM 형식
  productId: integer("product_id").references(() => products.id).notNull(),
  salesAmount: integer("sales_amount").notNull().default(0), // 제품별 매출 합계
  salesRatio: decimal("sales_ratio", { precision: 5, scale: 4 }).notNull().default("0"), // 해당 월 제품별 매출 비율 (0~1)
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 제품별 매출 비율 관계 정의
export const productSalesRatiosRelations = relations(productSalesRatios, ({ one }) => ({
  shop: one(shops, {
    fields: [productSalesRatios.shopId],
    references: [shops.id],
  }),
  kol: one(kols, {
    fields: [productSalesRatios.kolId],
    references: [kols.id],
  }),
  product: one(products, {
    fields: [productSalesRatios.productId],
    references: [products.id],
  }),
}));

// KOL 계층 구조 테이블
export const kolHierarchy = pgTable("kol_hierarchy", {
  id: serial("id").primaryKey(),
  parentKolId: integer("parent_kol_id").references(() => kols.id).notNull(),
  childKolId: integer("child_kol_id").references(() => kols.id).notNull(),
  childStartMonth: varchar("child_start_month", { length: 7 }).notNull(), // YYYY-MM 형식
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// KOL 계층 구조 관계 정의
export const kolHierarchyRelations = relations(kolHierarchy, ({ one }) => ({
  parentKol: one(kols, {
    fields: [kolHierarchy.parentKolId],
    references: [kols.id],
    relationName: "parentKols",
  }),
  childKol: one(kols, {
    fields: [kolHierarchy.childKolId],
    references: [kols.id],
    relationName: "childKols",
  }),
}));

// KOL 월별 요약 테이블
export const kolMonthlySummary = pgTable("kol_monthly_summary", {
  id: serial("id").primaryKey(),
  kolId: integer("kol_id").references(() => kols.id).notNull(),
  yearMonth: varchar("year_month", { length: 7 }).notNull(), // YYYY-MM 형식
  monthlySales: integer("monthly_sales").notNull().default(0), // 당월 매출
  monthlyCommission: integer("monthly_commission").notNull().default(0), // 당월 수당
  avgMonthlySales: decimal("avg_monthly_sales", { precision: 12, scale: 2 }).notNull().default("0"), // 월평균 매출 (최근 3개월 기준)
  cumulativeCommission: integer("cumulative_commission").notNull().default(0), // 누적 수당
  previousMonthSales: integer("previous_month_sales").notNull().default(0), // 전월 매출
  previousMonthCommission: integer("previous_month_commission").notNull().default(0), // 전월 수당
  activeShopsCount: integer("active_shops_count").notNull().default(0), // 당월 주문이 있는 전문점 수
  totalShopsCount: integer("total_shops_count").notNull().default(0), // 소속된 전체 전문점 수
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// KOL 월별 요약 관계 정의
export const kolMonthlySummaryRelations = relations(kolMonthlySummary, ({ one }) => ({
  kol: one(kols, {
    fields: [kolMonthlySummary.kolId],
    references: [kols.id],
  }),
}));

// 관리자 대시보드용 전체 KOL 통계 테이블
export const adminDashboardStats = pgTable("admin_dashboard_stats", {
  id: serial("id").primaryKey(),
  yearMonth: varchar("year_month", { length: 7 }).notNull(), // YYYY-MM 형식
  totalKolsCount: integer("total_kols_count").notNull().default(0), // 전체 KOL 수
  totalShopsCount: integer("total_shops_count").notNull().default(0), // 전체 전문점 수
  activeKolsCount: integer("active_kols_count").notNull().default(0), // 활동 중인 KOL 수 
  activeShopsCount: integer("active_shops_count").notNull().default(0), // 활동 중인 전문점 수
  totalSales: integer("total_sales").notNull().default(0), // 전체 매출 합계
  productSales: integer("product_sales").notNull().default(0), // 제품 매출 합계
  deviceSales: integer("device_sales").notNull().default(0), // 기기 매출 합계
  totalCommission: integer("total_commission").notNull().default(0), // 전체 수당 합계
  previousMonthSales: integer("previous_month_sales").notNull().default(0), // 전월 전체 매출
  previousMonthCommission: integer("previous_month_commission").notNull().default(0), // 전월 전체 수당
  salesGrowthRate: decimal("sales_growth_rate", { precision: 5, scale: 2 }).notNull().default("0"), // 매출 성장률 (%)
  commissionGrowthRate: decimal("commission_growth_rate", { precision: 5, scale: 2 }).notNull().default("0"), // 수당 성장률 (%)
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 관리자 통계를 위한 KOL별 월간 매출 합계 테이블
export const kolTotalMonthlySales = pgTable("kol_total_monthly_sales", {
  id: serial("id").primaryKey(),
  kolId: integer("kol_id").references(() => kols.id).notNull(),
  yearMonth: varchar("year_month", { length: 7 }).notNull(), // YYYY-MM 형식
  totalSales: integer("total_sales").notNull().default(0), // 해당 KOL의 모든 전문점 매출 합계
  productSales: integer("product_sales").notNull().default(0), // 제품 매출 합계
  deviceSales: integer("device_sales").notNull().default(0), // 기기 매출 합계
  totalCommission: integer("total_commission").notNull().default(0), // 수당 합계
  totalActiveShops: integer("total_active_shops").notNull().default(0), // 활동 중인 전문점 수
  totalShops: integer("total_shops").notNull().default(0), // 전체 전문점 수
  directSalesRatio: decimal("direct_sales_ratio", { precision: 5, scale: 2 }).notNull().default("0"), // 직접 판매 비율 (%)
  indirectSalesRatio: decimal("indirect_sales_ratio", { precision: 5, scale: 2 }).notNull().default("0"), // 간접 판매 비율 (%)
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// KOL별 월간 매출 합계 관계 정의
export const kolTotalMonthlySalesRelations = relations(kolTotalMonthlySales, ({ one }) => ({
  kol: one(kols, {
    fields: [kolTotalMonthlySales.kolId],
    references: [kols.id],
  }),
}));

// 전체 제품별 매출 비율 통계 테이블
export const productTotalSalesStats = pgTable("product_total_sales_stats", {
  id: serial("id").primaryKey(),
  yearMonth: varchar("year_month", { length: 7 }).notNull(), // YYYY-MM
  productId: integer("product_id").references(() => products.id).notNull(),
  totalSalesAmount: integer("total_sales_amount").notNull().default(0), // 제품별 전체 매출액
  salesRatio: decimal("sales_ratio", { precision: 5, scale: 4 }).notNull().default("0"), // 제품별 매출 비율
  salesGrowthRate: decimal("sales_growth_rate", { precision: 5, scale: 2 }).notNull().default("0"), // 전월 대비 성장률
  orderCount: integer("order_count").notNull().default(0), // 주문 수량
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 제품별 매출 비율 관계 정의
export const productTotalSalesStatsRelations = relations(productTotalSalesStats, ({ one }) => ({
  product: one(products, {
    fields: [productTotalSalesStats.productId],
    references: [products.id],
  }),
}));

// 관리자 권한 관리 테이블 (관리자가 특정 KOL 그룹만 관리하도록 설정)
export const adminKolAccess = pgTable("admin_kol_access", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(), // 관리자 사용자 ID
  kolId: integer("kol_id").references(() => kols.id).notNull(), // 접근 가능한 KOL ID
  accessLevel: varchar("access_level", { length: 50 }).notNull().default("view"), // view, edit, full_access 등
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 관리자 KOL 접근 권한 관계 정의
export const adminKolAccessRelations = relations(adminKolAccess, ({ one }) => ({
  user: one(users, {
    fields: [adminKolAccess.userId],
    references: [users.id],
  }),
  kol: one(kols, {
    fields: [adminKolAccess.kolId],
    references: [kols.id],
  }),
}));
</file>
  <file path="db/init-rpc.ts">
import { serverSupabase as supabaseAdmin } from '@/lib/supabase';
import { executeSql as execSql } from './utils/execute-sql';
import fs from 'fs';
import path from 'path';

/**
 * SQL 파일을 읽어서 반환하는 함수
 */
function readSqlFile(fileName: string): string {
  const filePath = path.join(process.cwd(), 'db', 'sql', fileName);
  if (!fs.existsSync(filePath)) {
    console.warn(`${filePath} 파일이 존재하지 않습니다.`);
    return '';
  }
  return fs.readFileSync(filePath, 'utf8');
}

/**
 * SQL을 직접 실행하는 함수
 */
async function executeSql(sql: string, description: string = ''): Promise<any> {
  // 외부 executeSql 함수 호출
  return execSql(sql, description);
}

export async function initializeRpcFunctions() {
  console.log('SQL 실행 RPC 함수 초기화 중...');
  
  // 1. exec_sql 함수 생성
  const execSqlFunctionSql = readSqlFile('create_exec_sql_function.sql');
  if (!execSqlFunctionSql) {
    console.error('exec_sql 함수 SQL 파일을 찾을 수 없습니다.');
    return { success: false, message: 'SQL 파일을 찾을 수 없습니다.' };
  }
  
  try {
    // exec_sql 함수가 없을 수 있으므로 직접 SQL을 실행
    const result = await directExecuteSql(execSqlFunctionSql);
    if (!result.success) {
      console.error('exec_sql 함수 생성 실패:', result);
      return result;
    }
    
    console.log('exec_sql 함수가 생성/업데이트되었습니다.');
    
    // 2. run_sql_query 함수 생성
    const runSqlQueryQuery = `
      CREATE OR REPLACE FUNCTION run_sql_query(sql_query text)
      RETURNS jsonb
      LANGUAGE plpgsql
      SECURITY DEFINER
      AS $$
      DECLARE
        result jsonb;
      BEGIN
        EXECUTE 'SELECT json_agg(t) FROM (' || sql_query || ') t' INTO result;
        RETURN result;
      EXCEPTION
        WHEN OTHERS THEN
          RETURN jsonb_build_object('error', SQLERRM, 'code', SQLSTATE);
      END;
      $$;
      
      ALTER FUNCTION run_sql_query(text) OWNER TO postgres;
      REVOKE ALL ON FUNCTION run_sql_query(text) FROM PUBLIC;
      GRANT EXECUTE ON FUNCTION run_sql_query(text) TO service_role;
    `;
    
    // exec_sql 함수를 사용해 run_sql_query 함수 생성
    const { data, error } = await supabaseAdmin.rpc('exec_sql', { _sql: runSqlQueryQuery });
    
    if (error) {
      console.error('run_sql_query 함수 생성 실패:', error);
      return { success: false, message: 'run_sql_query 함수 생성 실패', details: error };
    }
    
    console.log('run_sql_query 함수가 생성/업데이트되었습니다.');
    
    // 3. create_users_table 함수 생성 - 테이블이 없을 때 사용할 함수
    const createUsersTableQuery = `
      CREATE OR REPLACE FUNCTION create_users_table()
      RETURNS jsonb
      LANGUAGE plpgsql
      SECURITY DEFINER
      AS $$
      DECLARE
        result jsonb;
      BEGIN
        CREATE TABLE IF NOT EXISTS public.users (
          id SERIAL PRIMARY KEY,
          clerk_id VARCHAR(255) NOT NULL UNIQUE,
          email VARCHAR(255) NOT NULL UNIQUE,
          role VARCHAR(50) NOT NULL DEFAULT 'kol',
          created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL
        );
        
        -- 업데이트 트리거 추가
        CREATE OR REPLACE FUNCTION update_modified_column()
        RETURNS TRIGGER AS $$
        BEGIN
          NEW.updated_at = NOW();
          RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
        
        -- 트리거가 없으면 생성
        DROP TRIGGER IF EXISTS update_users_modtime ON public.users;
        CREATE TRIGGER update_users_modtime
          BEFORE UPDATE ON public.users
          FOR EACH ROW EXECUTE FUNCTION update_modified_column();
          
        RETURN jsonb_build_object('success', true, 'message', 'Users table created successfully');
      EXCEPTION
        WHEN OTHERS THEN
          RETURN jsonb_build_object('success', false, 'error', SQLERRM, 'code', SQLSTATE);
      END;
      $$;
      
      ALTER FUNCTION create_users_table() OWNER TO postgres;
      REVOKE ALL ON FUNCTION create_users_table() FROM PUBLIC;
      GRANT EXECUTE ON FUNCTION create_users_table() TO service_role;
    `;
    
    // exec_sql 함수를 사용해 create_users_table 함수 생성
    const { data: usersData, error: usersError } = await supabaseAdmin.rpc('exec_sql', { _sql: createUsersTableQuery });
    
    if (usersError) {
      console.error('create_users_table 함수 생성 실패:', usersError);
      return { success: false, message: 'create_users_table 함수 생성 실패', details: usersError };
    }
    
    console.log('create_users_table 함수가 생성/업데이트되었습니다.');
    
    return { success: true };
  } catch (error) {
    console.error('RPC 함수 초기화 중 오류 발생:', error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : String(error)
    };
  }
}

/**
 * exec_sql 함수가 없을 때 직접 SQL을 실행하는 함수
 */
async function directExecuteSql(sql: string): Promise<any> {
  try {
    // 직접 Supabase API를 호출하여 SQL 실행
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
    
    if (!supabaseUrl || !supabaseKey) {
      return { 
        success: false, 
        message: 'Supabase URL 또는 SERVICE_ROLE_KEY가 설정되지 않았습니다.' 
      };
    }
    
    // SQL 쿼리를 직접 실행하려면 Supabase에서 제공하는 SQL 실행 API를 사용
    // 이 예제에서는 PSQL 명령을 직접 실행하므로 설정된 RLS를 우회
    const response = await fetch(`${supabaseUrl}/rest/v1/`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': supabaseKey,
        'Authorization': `Bearer ${supabaseKey}`,
        'Prefer': 'params=single-object'
      },
      body: JSON.stringify({ query: sql }),
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      console.error('직접 SQL 실행 실패:', errorData);
      return { success: false, message: '직접 SQL 실행 실패', details: errorData };
    }
    
    const result = await response.json();
    return { success: true, data: result };
  } catch (error) {
    console.error('직접 SQL 실행 중 오류 발생:', error);
    return { 
      success: false, 
      message: '직접 SQL 실행 중 오류 발생', 
      details: error instanceof Error ? error.message : String(error)
    };
  }
}

// SQL 실행 함수를 외부로 노출
export { executeSql };
</file>
  <file path="db/migrate.ts">
import fs from 'fs';
import path from 'path';
import { serverSupabase as supabaseAdmin } from '@/lib/supabase';
import { initializeRpcFunctions } from './init-rpc';
import { executeSql } from './utils/execute-sql';

/**
 * SQL 파일의 내용을 읽어 반환하는 함수
 */
function readSqlFile(fileName: string): string {
  const filePath = path.join(process.cwd(), 'db', 'sql', fileName);
  if (!fs.existsSync(filePath)) {
    console.warn(`${filePath} 파일을 찾을 수 없습니다.`);
    return '';
  }
  return fs.readFileSync(filePath, 'utf8');
}

/**
 * 데이터베이스 마이그레이션 실행
 */
export async function migrateDatabase() {
  console.log('데이터베이스 마이그레이션을 시작합니다...');

  try {
    // 1. RPC 함수 초기화
    const rpcResult = await initializeRpcFunctions();
    console.log('RPC 함수 초기화 결과:', rpcResult);
    
    if (!rpcResult.success) {
      console.error('RPC 함수 초기화에 실패했습니다.');
      return { success: false, message: 'RPC 함수 초기화 실패', details: rpcResult };
    }
    
    // 2. 종속성 순서대로 테이블 생성
    const tables = [
      { name: 'users', file: 'create_users_table.sql', description: 'Users 테이블' },
      { name: 'whitelist', file: 'create_whitelist_table.sql', description: 'Whitelist 테이블' },
      { name: 'kols', file: 'create_kols_table.sql', description: 'KOLs 테이블' },
      { name: 'shops', file: 'create_shops_table.sql', description: 'Shops 테이블' }
    ];
    
    const tableResults = [];
    
    // 테이블 순서대로 생성
    for (const table of tables) {
      try {
        // 파일이 존재하는지 확인
        const sqlContent = readSqlFile(table.file);
        
        if (!sqlContent) {
          console.warn(`${table.file} 파일이 없습니다. 이 테이블은 건너뜁니다.`);
          continue;
        }
        
        // SQL 실행 - exec_sql RPC 함수 사용
        console.log(`${table.description} 생성 중...`);
        const result = await executeSql(sqlContent, table.description);
        
        tableResults.push({
          table: table.name,
          success: result.success,
          data: result.data,
          error: result.success ? null : result.message
        });
        
        console.log(`${table.name} 테이블 생성 결과:`, result.success ? '성공' : '실패');
      } catch (error) {
        console.error(`${table.name} 테이블 생성 중 오류:`, error);
        tableResults.push({
          table: table.name,
          success: false,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
    
    // 3. 테이블 존재 확인
    const { data, error } = await supabaseAdmin.from('users').select('count');
    if (error) {
      console.error('users 테이블이 없습니다:', error);
    } else {
      console.log('users 테이블이 확인되었습니다:', data);
    }

    console.log('데이터베이스 마이그레이션이 완료되었습니다.');
    return { success: true, tableResults, usersTable: error ? null : data };
  } catch (error) {
    console.error('데이터베이스 마이그레이션 실패:', error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : String(error)
    };
  }
}
</file>
  <file path="db/utils/execute-sql.ts">
import { serverSupabase as supabaseAdmin } from '@/lib/supabase';

/**
 * SQL을 실행하는 함수
 * @param sql 실행할 SQL 쿼리
 * @param description 로깅을 위한 설명
 * @returns 실행 결과
 */
export async function executeSql(sql: string, description: string = ''): Promise<any> {
  if (!sql) return { success: false, message: '실행할 SQL이 없습니다.' };
  
  try {
    console.log(`[${description}] SQL 실행 중...`);
    
    // 관리자 권한으로 SQL 직접 실행
    const { data, error } = await supabaseAdmin.rpc('exec_sql', { _sql: sql });
    
    if (error) {
      console.error(`[${description}] SQL 실행 오류:`, error);
      
      // 함수가 없는 경우
      if (error.code === 'PGRST202' || error.message.includes('Could not find the function')) {
        console.log('[주의] exec_sql 함수가 없습니다. Supabase SQL 에디터에서 직접 실행해주세요.');
        
        // REST API로 직접 SQL 실행 시도
        try {
          const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
          const response = await fetch(`${supabaseUrl}/rest/v1/`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'apikey': process.env.SUPABASE_SERVICE_ROLE_KEY!,
              'Authorization': `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY!}`,
              'Prefer': 'params=single-object'
            },
            body: JSON.stringify({ query: sql }),
          });
          
          if (!response.ok) {
            const result = await response.json();
            console.error('[REST API] SQL 실행 실패:', result);
            return { success: false, message: 'SQL 실행 실패 (REST API)', details: result };
          }
          
          const result = await response.json();
          console.log(`[${description}] REST API로 SQL 실행 성공:`, result);
          return { success: true, data: result };
        } catch (restError) {
          console.error('[REST API] 호출 실패:', restError);
          return { 
            success: false, 
            message: 'REST API 호출 실패', 
            details: restError instanceof Error ? restError.message : String(restError)
          };
        }
      }
      
      return { success: false, message: 'SQL 실행 실패', details: error };
    }
    
    console.log(`[${description}] SQL 실행 성공`);
    return { success: true, data };
  } catch (error) {
    console.error(`[${description}] SQL 실행 중 오류 발생:`, error);
    return { 
      success: false, 
      message: 'SQL 실행 중 오류 발생', 
      details: error instanceof Error ? error.message : String(error)
    };
  }
}

/**
 * Supabase 저장 프로시저 생성 스크립트
 * 
 * 이 SQL 스크립트를 Supabase SQL 편집기에서 실행하여 필요한 저장 프로시저를 생성합니다.
 */

// 제품별 매출 비율 데이터를 제품 정보와 함께 조회하는 함수
const getProductSalesWithDetailsSQL = `
CREATE OR REPLACE FUNCTION get_product_sales_with_details(month_param text)
RETURNS TABLE (
  id int,
  year_month text,
  product_id int,
  total_sales_amount int,
  sales_ratio decimal,
  sales_growth_rate decimal,
  product_name text,
  product_category text
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    pts.id,
    pts.year_month,
    pts.product_id,
    pts.total_sales_amount,
    pts.sales_ratio,
    pts.sales_growth_rate,
    p.name as product_name,
    p.category as product_category
  FROM 
    product_total_sales_stats pts
  INNER JOIN 
    products p ON pts.product_id = p.id
  WHERE 
    pts.year_month = month_param
  ORDER BY 
    pts.total_sales_amount DESC;
END;
$$ LANGUAGE plpgsql;
`;

/**
 * 저장 프로시저를 생성하는 함수
 * 
 * 이 함수는 스크립트를 직접 실행하지 않고 SQL 문을 반환합니다.
 * Supabase SQL 편집기에서 이 SQL을 실행하세요.
 */
export function generateStoredProcedures() {
  return [
    getProductSalesWithDetailsSQL,
    // 여기에 추가 저장 프로시저를 넣을 수 있습니다
  ].join('\n\n');
}

// 저장 프로시저 실행 경로를 제공하는 함수
export function suggestExecutionPath() {
  return {
    instructions: `
    다음 단계에 따라 저장 프로시저를 Supabase에 생성하세요:
    
    1. Supabase 대시보드에 로그인
    2. 왼쪽 메뉴에서 "SQL 편집기" 선택
    3. "New Query" 버튼 클릭
    4. 위의 SQL 코드를 복사하여 붙여넣기
    5. "Run" 버튼 클릭하여 저장 프로시저 생성
    6. "공개 액세스" 권한 부여 (API에서 호출할 수 있도록)
    `
  };
}
</file>
  <file path="db/utils/index.ts">
/**
 * Supabase와 DB 연동을 위한 유틸리티 함수
 */
import { createClient } from '@supabase/supabase-js';

// 환경 변수 체크 및 기본값 설정
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL ? process.env.NEXT_PUBLIC_SUPABASE_URL.trim() : '';
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ? process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY.trim() : '';
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY ? process.env.SUPABASE_SERVICE_ROLE_KEY.trim() : supabaseAnonKey;

// 환경 변수 로그 출력 (디버깅용)
if (typeof window === 'undefined') { // 서버 사이드에서만 실행
  console.log('DB Utils - Supabase URL:', supabaseUrl ? '설정됨' : '미설정');
  console.log('DB Utils - Supabase Anon Key:', supabaseAnonKey ? '설정됨' : '미설정');
  console.log('DB Utils - Supabase Service Key:', supabaseServiceKey ? '설정됨' : '미설정');
}

// URL 검증 함수
const isValidUrl = (url: string): boolean => {
  if (!url) return false;
  try {
    new URL(url);
    return true;
  } catch (e) {
    return false;
  }
};

// URL 검증 결과
const validSupabaseUrl = isValidUrl(supabaseUrl) 
  ? supabaseUrl 
  : 'https://placeholder-url.supabase.co';

const validSupabaseKey = supabaseAnonKey || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.placeholder';
const validServiceKey = supabaseServiceKey || validSupabaseKey;

if (!isValidUrl(supabaseUrl)) {
  console.error('⚠️ DB Utils - 유효하지 않은 Supabase URL입니다:', supabaseUrl);
  console.error('NEXT_PUBLIC_SUPABASE_URL 환경 변수를 확인해주세요.');
}

// Supabase 클라이언트 설정
export const supabase = createClient(validSupabaseUrl, validSupabaseKey, {
  auth: {
    persistSession: false,
  },
});

// Supabase Admin 클라이언트 설정
export const supabaseAdmin = createClient(validSupabaseUrl, validServiceKey, {
  auth: {
    persistSession: false,
  },
});

/**
 * 사용자 정보를 DB에 저장합니다.
 * @param clerkId Clerk 사용자 ID
 * @param email 이메일
 * @param role 역할
 * @returns 저장된 사용자 정보
 */
export async function saveUserToDB(clerkId: string, email: string, role: string) {
  try {
    const { data, error } = await supabase
      .from('users')
      .insert([
        { 
          clerk_id: clerkId,
          email,
          role,
        }
      ])
      .select();

    if (error) {
      console.error('사용자 저장 오류:', error);
      throw error;
    }

    return data;
  } catch (error) {
    console.error('사용자 저장 실패:', error);
    throw error;
  }
}

/**
 * 사용자 정보를 DB에서 삭제합니다.
 * @param clerkId Clerk 사용자 ID
 * @returns 삭제 결과
 */
export async function deleteUserFromDB(clerkId: string) {
  try {
    const { error } = await supabase
      .from('users')
      .delete()
      .eq('clerk_id', clerkId);

    if (error) {
      console.error('사용자 삭제 오류:', error);
      throw error;
    }

    return { success: true };
  } catch (error) {
    console.error('사용자 삭제 실패:', error);
    throw error;
  }
}

/**
 * Clerk 사용자 ID로 사용자 정보를 조회합니다.
 * @param clerkId Clerk 사용자 ID
 * @returns 사용자 정보
 */
export async function getUserByClerkId(clerkId: string) {
  try {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('clerk_id', clerkId)
      .single();

    if (error) {
      console.error('사용자 조회 오류:', error);
      throw error;
    }

    return data;
  } catch (error) {
    console.error('사용자 조회 실패:', error);
    throw error;
  }
}

/**
 * 모든 사용자 정보를 조회합니다.
 * @returns 사용자 목록
 */
export async function getAllUsers() {
  try {
    const { data, error } = await supabase
      .from('users')
      .select('*');

    if (error) {
      console.error('사용자 목록 조회 오류:', error);
      throw error;
    }

    return data;
  } catch (error) {
    console.error('사용자 목록 조회 실패:', error);
    throw error;
  }
}
</file>
  <file path="db/index.ts">
/**
 * 데이터베이스 액세스 모듈
 * 전체 애플리케이션에서 일관된 Supabase 클라이언트 제공
 */
import { serverSupabase } from '../lib/supabase';
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from './schema';

// Supabase 클라이언트 내보내기
export const supabase = serverSupabase;

// 기본 연결 설정
const connectionString = process.env.DATABASE_URL || '';
if (!connectionString) {
  throw new Error('DATABASE_URL 환경 변수가 설정되지 않았습니다.');
}

// 연결 풀 최적화 설정
const connectionPoolConfig = {
  max: 10,        // 최대 연결 수 증가
  idle_timeout: 30, // 유휴 연결 유지 시간
  connect_timeout: 10, // 연결 타임아웃 설정
};

// 연결 초기화 - 최적화된 설정 적용
const queryClient = postgres(connectionString, connectionPoolConfig);

// Drizzle ORM 초기화 및 내보내기
export const db = drizzle(queryClient, { schema });

// 이전 코드 호환성을 위해 getDB 함수도 유지
export async function getDB() {
  if (!connectionString) {
    throw new Error('DATABASE_URL 환경 변수가 설정되지 않았습니다.');
  }
  
  // Drizzle ORM 초기화 및 반환
  return db;
}

// SQL 헬퍼 함수
export const sql = {
  /**
   * 지정된 테이블의 모든 레코드를 조회
   * @param table 테이블 이름
   * @returns 테이블의 모든 레코드
   */
  async selectAll(table: string) {
    const { data, error } = await serverSupabase
      .from(table)
      .select('*');
      
    if (error) throw error;
    return data;
  },
  
  /**
   * 지정된 테이블에서 조건에 맞는 레코드 조회
   * @param table 테이블 이름
   * @param column 조건 컬럼
   * @param value 조건 값
   * @returns 조건에 맞는 레코드
   */
  async selectWhere(table: string, column: string, value: any) {
    const { data, error } = await serverSupabase
      .from(table)
      .select('*')
      .eq(column, value);
      
    if (error) throw error;
    return data;
  },
  
  /**
   * 지정된 테이블에 레코드 삽입
   * @param table 테이블 이름
   * @param record 삽입할 레코드
   * @returns 삽입된 레코드
   */
  async insert(table: string, record: any) {
    const { data, error } = await serverSupabase
      .from(table)
      .insert(record)
      .select();
      
    if (error) throw error;
    return data;
  },
  
  /**
   * 지정된 테이블의 레코드 수정
   * @param table 테이블 이름
   * @param id 수정할 레코드 ID
   * @param updates 수정할 내용
   * @returns 수정된 레코드
   */
  async update(table: string, id: number, updates: any) {
    const { data, error } = await serverSupabase
      .from(table)
      .update(updates)
      .eq('id', id)
      .select();
      
    if (error) throw error;
    return data;
  },
  
  /**
   * 지정된 테이블의 레코드 삭제
   * @param table 테이블 이름
   * @param id 삭제할 레코드 ID
   * @returns 삭제 결과
   */
  async delete(table: string, id: number) {
    const { error } = await serverSupabase
      .from(table)
      .delete()
      .eq('id', id);
      
    if (error) throw error;
    return { success: true };
  },
  
  /**
   * 원시 SQL 쿼리 실행
   * @param queryString SQL 쿼리 문자열
   * @param params 쿼리 파라미터
   * @returns 쿼리 결과
   */
  async raw(queryString: string, params?: any[]) {
    const { data, error } = await serverSupabase.rpc('execute_sql', {
      query_text: queryString,
      params: params || []
    });
    
    if (error) throw error;
    return data;
  }
};

// 스키마 타입 내보내기 (기존 타입 지원 유지)
export * from './schema';
</file>
  <file path="db/schema.ts">
import { pgTable, serial, varchar, timestamp, integer, boolean, text, numeric } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

// 사용자 테이블
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  clerkId: varchar("clerk_id", { length: 255 }).notNull().unique(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  name: varchar("name", { length: 255 }),
  role: varchar("role", { length: 50 }).notNull().default("kol"), // admin, kol
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 사용자 관계 정의
export const usersRelations = relations(users, ({ one, many }) => ({
  kol: one(kols, {
    fields: [users.id],
    references: [kols.userId],
  }),
  notifications: many(notifications),
}));

// KOL 테이블
export const kols = pgTable("kols", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  name: varchar("name", { length: 255 }).notNull(),
  shopName: varchar("shop_name", { length: 255 }).notNull(),
  region: varchar("region", { length: 100 }),
  smartPlaceLink: varchar("smart_place_link", { length: 500 }),
  status: varchar("status", { length: 50 }).default("active").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// KOL 관계 정의
export const kolsRelations = relations(kols, ({ one, many }) => ({
  user: one(users, {
    fields: [kols.userId],
    references: [users.id],
  }),
  shops: many(shops),
  dashboardMetrics: many(kolDashboardMetrics),
  totalMonthlySales: many(kolTotalMonthlySales),
  salesActivities: many(salesActivities),
  productSalesMetrics: many(productSalesMetrics),
}));

// 전문점 테이블
export const shops = pgTable("shops", {
  id: serial("id").primaryKey(),
  ownerName: varchar("owner_name", { length: 255 }).notNull(),
  shopName: varchar("shop_name", { length: 255 }).notNull(),
  kolId: integer("kol_id").references(() => kols.id).notNull(),
  region: varchar("region", { length: 100 }),
  smartPlaceLink: varchar("smart_place_link", { length: 500 }),
  isOwnerKol: boolean("is_owner_kol").default(false).notNull(),
  contractDate: timestamp("contract_date"),
  email: varchar("email", { length: 255 }),
  status: varchar("status", { length: 50 }).default("active").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 전문점 관계 정의
export const shopsRelations = relations(shops, ({ one, many }) => ({
  kol: one(kols, {
    fields: [shops.kolId],
    references: [kols.id],
  }),
  salesMetrics: many(shopSalesMetrics),
  salesActivities: many(salesActivities),
  productSalesMetrics: many(productSalesMetrics),
}));

// 제품 테이블
export const products = pgTable("products", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  price: integer("price").notNull(),
  isDevice: boolean("is_device").default(false).notNull(), // 기기(true) 또는 일반 제품(false)
  description: text("description"),
  image: varchar("image", { length: 500 }),
  category: varchar("category", { length: 100 }),
  status: varchar("status", { length: 50 }).default("active").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 제품 관계 정의
export const productsRelations = relations(products, ({ many }) => ({
  productSalesMetrics: many(productSalesMetrics),
  totalSalesStats: many(productTotalSalesStats),
}));

// 알림 테이블
export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  title: varchar("title", { length: 255 }).notNull(),
  content: varchar("content", { length: 1000 }).notNull(),
  read: boolean("read").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 알림 관계 정의
export const notificationsRelations = relations(notifications, ({ one }) => ({
  user: one(users, {
    fields: [notifications.userId],
    references: [users.id],
  }),
}));

// 영업 활동 테이블
export const salesActivities = pgTable("sales_activities", {
  id: serial("id").primaryKey(),
  kolId: integer("kol_id").references(() => kols.id).notNull(),
  shopId: integer("shop_id").references(() => shops.id),
  activityDate: timestamp("activity_date", { mode: 'date' }).defaultNow().notNull(),
  content: text("content").notNull(),
  activityType: varchar("activity_type", { length: 50 }).default("general"),
  shopName: text("shop_name"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 영업 활동 관계 정의
export const salesActivitiesRelations = relations(salesActivities, ({ one }) => ({
  kol: one(kols, {
    fields: [salesActivities.kolId],
    references: [kols.id],
  }),
  shop: one(shops, {
    fields: [salesActivities.shopId],
    references: [shops.id],
  }),
}));

// KOL 대시보드 메트릭 테이블
export const kolDashboardMetrics = pgTable("kol_dashboard_metrics", {
  id: serial("id").primaryKey(),
  kolId: integer("kol_id").references(() => kols.id).notNull(),
  yearMonth: varchar("year_month", { length: 7 }).notNull(), // YYYY-MM 형식
  monthlySales: integer("monthly_sales").default(0).notNull(),
  monthlyCommission: integer("monthly_commission").default(0).notNull(),
  activeShopsCount: integer("active_shops_count").default(0).notNull(),
  totalShopsCount: integer("total_shops_count").default(0).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// KOL 대시보드 메트릭 관계 정의
export const kolDashboardMetricsRelations = relations(kolDashboardMetrics, ({ one }) => ({
  kol: one(kols, {
    fields: [kolDashboardMetrics.kolId],
    references: [kols.id],
  }),
}));

// 전문점 매출 메트릭 테이블
export const shopSalesMetrics = pgTable("shop_sales_metrics", {
  id: serial("id").primaryKey(),
  shopId: integer("shop_id").references(() => shops.id).notNull(),
  yearMonth: varchar("year_month", { length: 7 }).notNull(), // YYYY-MM 형식
  totalSales: integer("total_sales").default(0).notNull(),
  productSales: integer("product_sales").default(0).notNull(),
  deviceSales: integer("device_sales").default(0).notNull(),
  commission: integer("commission").default(0).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 전문점 매출 메트릭 관계 정의
export const shopSalesMetricsRelations = relations(shopSalesMetrics, ({ one }) => ({
  shop: one(shops, {
    fields: [shopSalesMetrics.shopId],
    references: [shops.id],
  }),
}));

// 제품 매출 메트릭 테이블
export const productSalesMetrics = pgTable("product_sales_metrics", {
  id: serial("id").primaryKey(),
  kolId: integer("kol_id").references(() => kols.id).notNull(),
  productId: integer("product_id").references(() => products.id).notNull(),
  shopId: integer("shop_id").references(() => shops.id),
  yearMonth: varchar("year_month", { length: 7 }).notNull(), // YYYY-MM 형식
  quantity: integer("quantity").default(0).notNull(),
  salesAmount: integer("sales_amount").default(0).notNull(),
  salesRatio: numeric("sales_ratio").default("0").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});

// 제품 매출 메트릭 관계 정의
export const productSalesMetricsRelations = relations(productSalesMetrics, ({ one }) => ({
  kol: one(kols, {
    fields: [productSalesMetrics.kolId],
    references: [kols.id],
  }),
  product: one(products, {
    fields: [productSalesMetrics.productId],
    references: [products.id],
  }),
  shop: one(shops, {
    fields: [productSalesMetrics.shopId],
    references: [shops.id],
  }),
}));

// KOL 총 월간 매출 테이블
export const kolTotalMonthlySales = pgTable("kol_total_monthly_sales", {
  id: serial("id").primaryKey(),
  kolId: integer("kol_id").references(() => kols.id).notNull(),
  yearMonth: varchar("year_month", { length: 7 }).notNull(), // YYYY-MM 형식
  totalSales: integer("total_sales").default(0).notNull(),
  productSales: integer("product_sales").default(0).notNull(),
  deviceSales: integer("device_sales").default(0).notNull(),
  totalCommission: integer("total_commission").default(0).notNull(),
  totalActiveShops: integer("total_active_shops").default(0).notNull(),
  totalShops: integer("total_shops").default(0).notNull(),
  directSalesRatio: numeric("direct_sales_ratio").default("0").notNull(),
  indirectSalesRatio: numeric("indirect_sales_ratio").default("0").notNull(),
  createdAt: timestamp("created_at", { withTimezone: false }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: false }).defaultNow().notNull()
});

// KOL 총 월간 매출 관계 정의
export const kolTotalMonthlySalesRelations = relations(kolTotalMonthlySales, ({ one }) => ({
  kol: one(kols, {
    fields: [kolTotalMonthlySales.kolId],
    references: [kols.id],
  }),
}));

// 제품 총 매출 통계 테이블
export const productTotalSalesStats = pgTable("product_total_sales_stats", {
  id: serial("id").primaryKey(),
  yearMonth: varchar("year_month", { length: 7 }).notNull(), // YYYY-MM 형식
  productId: integer("product_id").references(() => products.id).notNull(),
  totalSalesAmount: integer("total_sales_amount").default(0).notNull(),
  salesRatio: numeric("sales_ratio").default("0").notNull(),
  salesGrowthRate: numeric("sales_growth_rate").default("0").notNull(),
  orderCount: integer("order_count").default(0).notNull(),
  createdAt: timestamp("created_at", { withTimezone: false }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: false }).defaultNow().notNull()
});

// 제품 총 매출 통계 관계 정의
export const productTotalSalesStatsRelations = relations(productTotalSalesStats, ({ one }) => ({
  product: one(products, {
    fields: [productTotalSalesStats.productId],
    references: [products.id],
  }),
}));
</file>
</code>