<?xml version="1.0" encoding="UTF-8"?>
<code>
  <file path="lib/api-fetch.ts">
/**
 * API 호출을 위한 유틸리티 함수들
 * 
 * 모든 API 호출에서 인증 정보와 함께 요청을 보내기 위한 함수들을 제공합니다.
 * Supabase 세션 쿠키가 자동으로 전송되도록 credentials: 'include' 옵션을 사용합니다.
 */

/**
 * 인증 정보를 포함한 API 요청을 수행하는 함수
 * 모든 API 호출에서 이 함수를 사용하면 Supabase 인증이 자동으로 처리됩니다.
 * 
 * @param url API 엔드포인트 URL
 * @param options fetch 옵션
 * @returns fetch 응답
 */
export const fetchWithAuth = async (url: string, options: RequestInit = {}) => {
  // credentials: 'include'를 설정하여 쿠키가 요청과 함께 전송되도록 합니다
  const defaultOptions: RequestInit = {
    credentials: 'include',
    headers: {
      'Content-Type': 'application/json',
    },
  };

  // 옵션 병합
  const mergedOptions = {
    ...defaultOptions,
    ...options,
    headers: {
      ...defaultOptions.headers,
      ...options.headers,
    },
  };

  try {
    const response = await fetch(url, mergedOptions);
    
    // 401 (Unauthorized) 응답을 받았을 때 처리
    if (response.status === 401) {
      console.error('인증 실패: API 세션이 만료되었거나 유효하지 않습니다.');
      
      // 로그인 페이지로 리다이렉트 (선택적)
      // window.location.href = '/signin';
    }
    
    return response;
  } catch (error) {
    console.error('API 요청 중 오류 발생:', error);
    throw error;
  }
};

/**
 * GET 요청을 수행하는 함수
 * 
 * @param url API 엔드포인트 URL
 * @param options 추가 옵션
 * @returns fetch 응답
 */
export const getWithAuth = (url: string, options: RequestInit = {}) => {
  return fetchWithAuth(url, {
    method: 'GET',
    ...options,
  });
};

/**
 * POST 요청을 수행하는 함수
 * 
 * @param url API 엔드포인트 URL
 * @param data 요청 본문 데이터
 * @param options 추가 옵션
 * @returns fetch 응답
 */
export const postWithAuth = (url: string, data: any, options: RequestInit = {}) => {
  return fetchWithAuth(url, {
    method: 'POST',
    body: JSON.stringify(data),
    ...options,
  });
};

/**
 * PUT 요청을 수행하는 함수
 * 
 * @param url API 엔드포인트 URL
 * @param data 요청 본문 데이터
 * @param options 추가 옵션
 * @returns fetch 응답
 */
export const putWithAuth = (url: string, data: any, options: RequestInit = {}) => {
  return fetchWithAuth(url, {
    method: 'PUT',
    body: JSON.stringify(data),
    ...options,
  });
};

/**
 * PATCH 요청을 수행하는 함수
 * 
 * @param url API 엔드포인트 URL
 * @param data 요청 본문 데이터
 * @param options 추가 옵션
 * @returns fetch 응답
 */
export const patchWithAuth = (url: string, data: any, options: RequestInit = {}) => {
  return fetchWithAuth(url, {
    method: 'PATCH',
    body: JSON.stringify(data),
    ...options,
  });
};

/**
 * DELETE 요청을 수행하는 함수
 * 
 * @param url API 엔드포인트 URL
 * @param options 추가 옵션
 * @returns fetch 응답
 */
export const deleteWithAuth = (url: string, options: RequestInit = {}) => {
  return fetchWithAuth(url, {
    method: 'DELETE',
    ...options,
  });
};
</file>
  <file path="lib/clerk-client.ts">
/**
 * Clerk API 클라이언트 초기화
 * Next.js 15 호환성 문제로 직접 API 호출 방식으로 대체
 */
import directClerkApi from './clerk-direct-api';

// 타입을 맞추기 위한 클라이언트 래퍼
export const clerkClient = {
  users: {
    // 직접 API 클라이언트 메소드 매핑
    getUserList: async (options: any = {}) => {
      const limit = options?.limit || 10;
      const offset = options?.offset || 0;
      return directClerkApi.getUserList(limit, offset);
    },
    getUser: async (userId: string) => {
      return directClerkApi.getUser(userId);
    },
    createUser: async (userData: any) => {
      return directClerkApi.createUser({
        email_address: Array.isArray(userData.emailAddress) ? userData.emailAddress[0] : userData.emailAddress,
        password: userData.password,
        first_name: userData.firstName,
        last_name: userData.lastName
      });
    },
    updateUserMetadata: async (userId: string, metadata: any) => {
      return directClerkApi.updateUserMetadata(userId, metadata);
    },
    deleteUser: async (userId: string) => {
      return directClerkApi.deleteUser(userId);
    }
  },
  sessions: {
    getSessionList: async (options: any = {}) => {
      const limit = options?.limit || 10;
      return directClerkApi.getActiveSessions(limit);
    },
    getSession: async (sessionId: string) => {
      return directClerkApi.getSession(sessionId);
    }
  },
  verifyToken: async (token: string) => {
    return directClerkApi.verifyToken(token);
  }
};

// 직접 호출 API도 함께 내보내기
export const directApiClient = directClerkApi;
</file>
  <file path="lib/clerk-direct-api.ts">
/**
 * Clerk Direct API Client
 * Next.js 15와 Clerk 호환성 문제를 해결하기 위한 직접 API 호출 구현
 */

// Clerk API 설정
const CLERK_API_BASE = 'https://api.clerk.dev/v1';
const CLERK_SECRET_KEY = process.env.CLERK_SECRET_KEY;

// 공통 헤더 설정
const getHeaders = () => {
  return {
    'Authorization': `Bearer ${CLERK_SECRET_KEY}`,
    'Content-Type': 'application/json',
  };
};

// API 요청 유틸리티 함수
async function makeRequest(url: string, options: RequestInit = {}) {
  if (!CLERK_SECRET_KEY) {
    throw new Error('CLERK_SECRET_KEY 환경 변수가 설정되지 않았습니다.');
  }

  const fullUrl = `${CLERK_API_BASE}${url}`;
  
  try {
    const response = await fetch(fullUrl, {
      ...options,
      headers: {
        ...getHeaders(),
        ...options.headers,
      },
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(
        `Clerk API 오류: ${response.status} ${response.statusText} - ${
          errorData.message || JSON.stringify(errorData)
        }`
      );
    }

    return await response.json();
  } catch (error) {
    console.error('Clerk API 요청 실패:', error);
    throw error;
  }
}

/**
 * 사용자 목록을 조회합니다
 * @param limit 최대 사용자 수
 * @param offset 시작 오프셋
 */
export async function getUserList(limit = 10, offset = 0) {
  return makeRequest(`/users?limit=${limit}&offset=${offset}`);
}

/**
 * 특정 사용자 정보를 조회합니다
 * @param userId 사용자 ID
 */
export async function getUser(userId: string) {
  return makeRequest(`/users/${userId}`);
}

/**
 * 새 사용자를 생성합니다
 * @param userData 사용자 데이터
 */
export async function createUser(userData: {
  email_address: string[];
  password: string;
  first_name?: string;
  last_name?: string;
  public_metadata?: Record<string, any>;
}) {
  return makeRequest('/users', {
    method: 'POST',
    body: JSON.stringify(userData),
  });
}

/**
 * 사용자 메타데이터를 업데이트합니다
 * @param userId 사용자 ID
 * @param metadata 메타데이터
 */
export async function updateUserMetadata(userId: string, metadata: {
  public_metadata?: Record<string, any>;
  private_metadata?: Record<string, any>;
}) {
  return makeRequest(`/users/${userId}/metadata`, {
    method: 'PATCH',
    body: JSON.stringify(metadata),
  });
}

/**
 * 사용자를 삭제합니다
 * @param userId 사용자 ID
 */
export async function deleteUser(userId: string) {
  return makeRequest(`/users/${userId}`, {
    method: 'DELETE',
  });
}

/**
 * 세션 정보를 조회합니다
 * @param sessionId 세션 ID
 */
export async function getSession(sessionId: string) {
  return makeRequest(`/sessions/${sessionId}`);
}

/**
 * 현재 활성 세션 목록을 조회합니다
 * @param limit 최대 세션 수
 */
export async function getActiveSessions(limit = 10) {
  return makeRequest(`/sessions?limit=${limit}`);
}

/**
 * JWT 토큰 검증
 * @param token JWT 토큰
 */
export async function verifyToken(token: string) {
  return makeRequest('/tokens/verify', {
    method: 'POST',
    body: JSON.stringify({ token }),
  });
}

/**
 * 사용자 역할 조회
 * @param userId 사용자 ID
 */
export async function getUserRole(userId: string) {
  const user = await getUser(userId);
  return user?.public_metadata?.role || null;
}

export default {
  getUserList,
  getUser,
  createUser,
  updateUserMetadata,
  deleteUser,
  getSession,
  getActiveSessions,
  verifyToken,
  getUserRole,
};
</file>
  <file path="lib/db.ts">
import { Pool } from 'pg';

// 데이터베이스 연결 설정
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : undefined,
});

// 쿼리 실행 함수
const query = async (text: string, params?: any[]) => {
  const start = Date.now();
  try {
    const res = await pool.query(text, params);
    const duration = Date.now() - start;
    console.log('쿼리 실행:', { text, duration, rows: res.rowCount });
    return res;
  } catch (error) {
    console.error('쿼리 오류:', error);
    throw error;
  }
};

// 데이터베이스 인터페이스
export const db = {
  query,
  pool,
};
</file>
  <file path="lib/supabase-client.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '';

// 클라이언트 컴포넌트에서 사용하는 Supabase 클라이언트
export const supabaseClient = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
  },
});

/**
 * API 요청 시 사용할 fetchOptions 
 * (Supabase 세션 쿠키를 API 요청에 포함시키기 위해 사용)
 */
export const fetchWithAuth = async (url: string, options: RequestInit = {}) => {
  // credentials: 'include'를 설정하여 쿠키가 요청과 함께 전송되도록 합니다
  const defaultOptions: RequestInit = {
    credentials: 'include',
    headers: {
      'Content-Type': 'application/json',
    },
  };

  // 옵션 병합
  const mergedOptions = {
    ...defaultOptions,
    ...options,
    headers: {
      ...defaultOptions.headers,
      ...options.headers,
    },
  };

  try {
    const response = await fetch(url, mergedOptions);
    
    // 401 (Unauthorized) 응답을 받았을 때 처리
    if (response.status === 401) {
      console.error('인증 실패: API 세션이 만료되었거나 유효하지 않습니다.');
      
      // 로그인 페이지로 리다이렉트 (선택적)
      // window.location.href = '/signin';
    }
    
    return response;
  } catch (error) {
    console.error('API 요청 중 오류 발생:', error);
    throw error;
  }
};

/**
 * 클라이언트에서의 Supabase 로그인 처리
 * (이메일/비밀번호 로그인)
 */
export const signInWithEmail = async (email: string, password: string) => {
  try {
    const { data, error } = await supabaseClient.auth.signInWithPassword({
      email,
      password,
    });
    
    if (error) {
      throw error;
    }
    
    return data;
  } catch (error) {
    console.error('로그인 실패:', error);
    throw error;
  }
};

/**
 * 로그아웃 처리
 */
export const signOut = async () => {
  try {
    const { error } = await supabaseClient.auth.signOut();
    
    if (error) {
      throw error;
    }
    
    // 로그아웃 후 메인 페이지로 리다이렉트 (선택적)
    // window.location.href = '/';
  } catch (error) {
    console.error('로그아웃 실패:', error);
    throw error;
  }
};

/**
 * 현재 인증된 사용자 정보 가져오기
 */
export const getCurrentUser = async () => {
  try {
    const { data: { user }, error } = await supabaseClient.auth.getUser();
    
    if (error) {
      throw error;
    }
    
    return user;
  } catch (error) {
    console.error('사용자 정보 조회 실패:', error);
    return null;
  }
};

/**
 * 세션 상태 구독 (세션 변경 감지)
 * @param callback 세션 변경 시 호출될 콜백 함수
 */
export const subscribeToAuthChanges = (
  callback: (event: any, session: any) => void
) => {
  const { data: { subscription } } = supabaseClient.auth.onAuthStateChange(callback);
  return () => subscription.unsubscribe();
};
</file>
  <file path="lib/types.ts">
// Supabase 데이터베이스 타입 정의
export type Database = {
  public: {
    Tables: {
      users: {
        Row: {
          id: number
          clerk_id: string
          email: string
          name: string | null
          role: string
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          clerk_id: string
          email: string
          name?: string | null
          role?: string
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: number
          clerk_id?: string
          email?: string
          name?: string | null
          role?: string
          created_at?: string
          updated_at?: string
        }
      }
      kols: {
        Row: {
          id: number
          user_id: number
          name: string
          shop_name: string
          region: string | null
          smart_place_link: string | null
          status: string
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          user_id: number
          name: string
          shop_name: string
          region?: string | null
          smart_place_link?: string | null
          status?: string
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: number
          user_id?: number
          name?: string
          shop_name?: string
          region?: string | null
          smart_place_link?: string | null
          status?: string
          created_at?: string
          updated_at?: string
        }
      }
      shops: {
        Row: {
          id: number
          owner_name: string
          shop_name: string
          kol_id: number
          region: string | null
          smart_place_link: string | null
          is_owner_kol: boolean
          contract_date: string | null
          email: string | null
          status: string
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          owner_name: string
          shop_name: string
          kol_id: number
          region?: string | null
          smart_place_link?: string | null
          is_owner_kol?: boolean
          contract_date?: string | null
          email?: string | null
          status?: string
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: number
          owner_name?: string
          shop_name?: string
          kol_id?: number
          region?: string | null
          smart_place_link?: string | null
          is_owner_kol?: boolean
          contract_date?: string | null
          email?: string | null
          status?: string
          created_at?: string
          updated_at?: string
        }
      }
      products: {
        Row: {
          id: number
          name: string
          price: number
          is_device: boolean
          description: string | null
          image: string | null
          category: string | null
          status: string
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          name: string
          price: number
          is_device?: boolean
          description?: string | null
          image?: string | null
          category?: string | null
          status?: string
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: number
          name?: string
          price?: number
          is_device?: boolean
          description?: string | null
          image?: string | null
          category?: string | null
          status?: string
          created_at?: string
          updated_at?: string
        }
      }
      notifications: {
        Row: {
          id: number
          user_id: number
          title: string
          content: string
          read: boolean
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          user_id: number
          title: string
          content: string
          read?: boolean
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: number
          user_id?: number
          title?: string
          content?: string
          read?: boolean
          created_at?: string
          updated_at?: string
        }
      }
      sales_activities: {
        Row: {
          id: number
          kol_id: number
          shop_id: number | null
          activity_date: string
          content: string
          activity_type: 'general' | 'visit' | null
          shop_name: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          kol_id: number
          shop_id?: number | null
          activity_date?: string
          content: string
          activity_type?: 'general' | 'visit' | null
          shop_name?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: number
          kol_id?: number
          shop_id?: number | null
          activity_date?: string
          content?: string
          activity_type?: 'general' | 'visit' | null
          shop_name?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      kol_dashboard_metrics: {
        Row: {
          id: number
          kol_id: number
          year_month: string
          monthly_sales: number
          monthly_commission: number
          active_shops_count: number
          total_shops_count: number
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          kol_id: number
          year_month: string
          monthly_sales?: number
          monthly_commission?: number
          active_shops_count?: number
          total_shops_count?: number
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: number
          kol_id?: number
          year_month?: string
          monthly_sales?: number
          monthly_commission?: number
          active_shops_count?: number
          total_shops_count?: number
          created_at?: string
          updated_at?: string
        }
      }
      shop_sales_metrics: {
        Row: {
          id: number
          shop_id: number
          year_month: string
          total_sales: number
          product_sales: number
          device_sales: number
          commission: number
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          shop_id: number
          year_month: string
          total_sales?: number
          product_sales?: number
          device_sales?: number
          commission?: number
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: number
          shop_id?: number
          year_month?: string
          total_sales?: number
          product_sales?: number
          device_sales?: number
          commission?: number
          created_at?: string
          updated_at?: string
        }
      }
      product_sales_metrics: {
        Row: {
          id: number
          kol_id: number
          product_id: number
          shop_id: number | null
          year_month: string
          quantity: number
          sales_amount: number
          sales_ratio: number
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          kol_id: number
          product_id: number
          shop_id?: number | null
          year_month: string
          quantity?: number
          sales_amount?: number
          sales_ratio?: number
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: number
          kol_id?: number
          product_id?: number
          shop_id?: number | null
          year_month?: string
          quantity?: number
          sales_amount?: number
          sales_ratio?: number
          created_at?: string
          updated_at?: string
        }
      }
      kol_total_monthly_sales: {
        Row: {
          id: number
          kol_id: number
          year_month: string
          total_sales: number
          product_sales: number
          device_sales: number
          total_commission: number
          total_active_shops: number
          total_shops: number
          direct_sales_ratio: number
          indirect_sales_ratio: number
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          kol_id: number
          year_month: string
          total_sales?: number
          product_sales?: number
          device_sales?: number
          total_commission?: number
          total_active_shops?: number
          total_shops?: number
          direct_sales_ratio?: number
          indirect_sales_ratio?: number
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: number
          kol_id?: number
          year_month?: string
          total_sales?: number
          product_sales?: number
          device_sales?: number
          total_commission?: number
          total_active_shops?: number
          total_shops?: number
          direct_sales_ratio?: number
          indirect_sales_ratio?: number
          created_at?: string
          updated_at?: string
        }
      }
      product_total_sales_stats: {
        Row: {
          id: number
          year_month: string
          product_id: number
          total_sales_amount: number
          sales_ratio: number
          sales_growth_rate: number
          order_count: number
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          year_month: string
          product_id: number
          total_sales_amount?: number
          sales_ratio?: number
          sales_growth_rate?: number
          order_count?: number
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: number
          year_month?: string
          product_id?: number
          total_sales_amount?: number
          sales_ratio?: number
          sales_growth_rate?: number
          order_count?: number
          created_at?: string
          updated_at?: string
        }
      }
    }
    // 복잡한 쿼리 결과에 대한 타입 정의
    Views: {}
    Functions: {}
  }
}

// 애플리케이션에서 사용할 타입 정의
export type User = Database['public']['Tables']['users']['Row']
export type Kol = Database['public']['Tables']['kols']['Row']
export type Shop = Database['public']['Tables']['shops']['Row']
export type Product = Database['public']['Tables']['products']['Row']
export type Notification = Database['public']['Tables']['notifications']['Row']
export type SalesActivity = Database['public']['Tables']['sales_activities']['Row']
export type KolDashboardMetric = Database['public']['Tables']['kol_dashboard_metrics']['Row']
export type ShopSalesMetric = Database['public']['Tables']['shop_sales_metrics']['Row']
export type ProductSalesMetric = Database['public']['Tables']['product_sales_metrics']['Row']
export type KolTotalMonthlySale = Database['public']['Tables']['kol_total_monthly_sales']['Row']
export type ProductTotalSalesStat = Database['public']['Tables']['product_total_sales_stats']['Row']

// 카멜케이스로 변환된 타입 (프론트엔드에서 사용)
export type UserCamel = {
  id: number
  clerkId: string
  email: string
  name: string | null
  role: string
  createdAt: string
  updatedAt: string
}

export type KolCamel = {
  id: number
  userId: number
  name: string
  shopName: string
  region: string | null
  smartPlaceLink: string | null
  status: string
  createdAt: string
  updatedAt: string
}

export type ShopCamel = {
  id: number
  ownerName: string
  shopName: string
  kolId: number
  region: string | null
  smartPlaceLink: string | null
  isOwnerKol: boolean
  contractDate: string | null
  email: string | null
  status: string
  createdAt: string
  updatedAt: string
}

export type SalesActivityCamel = {
  id: number
  kolId: number
  shopId: number | null
  activityDate: string
  content: string
  activityType: 'general' | 'visit' | null
  shopName: string | null
  createdAt: string
  updatedAt: string
}

export type KolDashboardMetricCamel = {
  id: number
  kolId: number
  yearMonth: string
  monthlySales: number
  monthlyCommission: number
  activeShopsCount: number
  totalShopsCount: number
  createdAt: string
  updatedAt: string
}

export type ShopSalesMetricCamel = {
  id: number
  shopId: number
  yearMonth: string
  totalSales: number
  productSales: number
  deviceSales: number
  commission: number
  createdAt: string
  updatedAt: string
}

// 대시보드 데이터 타입 (kol-new 페이지에서 사용)
export type DashboardData = {
  kol: {
    id: number
    name: string
    shopName: string
  }
  sales: {
    currentMonth: number
    previousMonth: number
    growth: number
  }
  allowance: {
    currentMonth: number
    previousMonth: number
    growth: number
  }
  shops: {
    total: number
    ordering: number
    notOrdering: number
    lastAddedDate?: string
  }
}
</file>
  <file path="lib/clerk/admin.ts">
/**
 * Clerk Admin API 유틸리티 함수
 * 관리자 페이지에서 사용자 관리를 위한 함수들을 제공합니다.
 * Next.js 15와 Clerk 호환성 문제로 직접 API 호출 방식으로 구현됩니다.
 */
import clerkApi from "../clerk-direct-api";

// 사용자 데이터 타입 정의
interface ClerkUser {
  id: string;
  email_addresses?: Array<{ email_address: string }>;
  first_name?: string;
  last_name?: string;
  public_metadata?: Record<string, any>;
  private_metadata?: Record<string, any>;
}

/**
 * 새 사용자를 생성합니다
 * @param email 사용자 이메일
 * @param password 비밀번호
 * @param firstName 이름
 * @param lastName 성
 * @param role 역할 (본사관리자 또는 kol)
 * @returns 생성된 사용자 정보
 */
export async function createUser(
  email: string,
  password: string,
  firstName: string,
  lastName: string,
  role: string
) {
  try {
    console.log("Clerk Admin: 사용자 생성 시작", { email, firstName, lastName, role });
    // 직접 API 호출로 사용자 생성 - 생성 시 역할도 함께 설정
    const user = await clerkApi.createUser({
      email_address: [email],
      password,
      first_name: firstName,
      last_name: lastName,
      public_metadata: {
        role,
      },
    });

    console.log("Clerk Admin: 사용자 생성 및 역할 설정 완료:", user.id);
    return user;
  } catch (error) {
    console.error("Clerk Admin: 사용자 생성 실패:", error);
    throw error;
  }
}

/**
 * 사용자 역할을 업데이트합니다
 * @param userId 사용자 ID
 * @param role 역할 (본사관리자 또는 kol)
 * @returns 업데이트된 사용자 정보
 */
export async function updateUserRole(userId: string, role: string) {
  try {
    console.log("Clerk Admin: 사용자 역할 업데이트 시작", { userId, role });
    const user = await clerkApi.updateUserMetadata(userId, {
      public_metadata: {
        role,
      },
    });
    console.log("Clerk Admin: 사용자 역할 업데이트 완료");
    return user;
  } catch (error) {
    console.error("Clerk Admin: 사용자 역할 업데이트 실패:", error);
    throw error;
  }
}

/**
 * 사용자를 삭제합니다
 * @param userId 사용자 ID
 * @returns 삭제 결과
 */
export async function deleteUser(userId: string) {
  try {
    console.log("Clerk Admin: 사용자 삭제 시작", userId);
    const result = await clerkApi.deleteUser(userId);
    console.log("Clerk Admin: 사용자 삭제 완료");
    return result;
  } catch (error) {
    console.error("Clerk Admin: 사용자 삭제 실패:", error);
    throw error;
  }
}

/**
 * 모든 사용자를 조회합니다
 * @returns 사용자 목록
 */
export async function getAllUsers() {
  try {
    console.log("Clerk Admin: 사용자 목록 조회 시작");
    const users = await clerkApi.getUserList(100, 0); // 최대 100명 조회
    console.log(`Clerk Admin: 사용자 목록 조회 완료 (${users.length}명)`);
    return users;
  } catch (error) {
    console.error("Clerk Admin: 사용자 목록 조회 실패:", error);
    throw error;
  }
}

/**
 * 특정 역할을 가진 사용자를 조회합니다
 * @param role 역할 (본사관리자 또는 kol)
 * @returns 해당 역할을 가진 사용자 목록
 */
export async function getUsersByRole(role: string) {
  try {
    console.log(`Clerk Admin: ${role} 역할 사용자 목록 조회 시작`);
    // 모든 사용자를 가져와서 필터링
    const allUsers = await clerkApi.getUserList(100, 0);
    const filteredUsers = allUsers.filter((user: ClerkUser) => 
      user.public_metadata && user.public_metadata.role === role
    );
    console.log(`Clerk Admin: ${role} 역할 사용자 목록 조회 완료 (${filteredUsers.length}명)`);
    return filteredUsers;
  } catch (error) {
    console.error(`Clerk Admin: ${role} 역할 사용자 목록 조회 실패:`, error);
    throw error;
  }
}
</file>
  <file path="lib/date-utils.ts">
/**
 * 날짜 관련 유틸리티 함수
 */

/**
 * 오늘 날짜를 YYYY-MM-DD 형식으로 반환
 */
export function getCurrentDate(): string {
  const now = new Date();
  return now.toISOString().split('T')[0];
}

/**
 * 주어진 날짜의 전월을 YYYY-MM 형식으로 반환
 * @param dateStr YYYY-MM-DD 형식의 날짜 문자열
 */
export function getPreviousMonth(dateStr: string): string {
  const date = new Date(dateStr);
  date.setMonth(date.getMonth() - 1);
  
  const year = date.getFullYear();
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  
  return `${year}-${month}`;
}

/**
 * 주어진 날짜의 다음 월을 YYYY-MM 형식으로 반환
 * @param dateStr YYYY-MM-DD 형식의 날짜 문자열
 */
export function getNextMonth(dateStr: string): string {
  const date = new Date(dateStr);
  date.setMonth(date.getMonth() + 1);
  
  const year = date.getFullYear();
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  
  return `${year}-${month}`;
}

/**
 * 날짜 범위의 모든 월을 YYYY-MM 형식 배열로 반환
 * @param startDate YYYY-MM-DD 형식 시작일
 * @param endDate YYYY-MM-DD 형식 종료일
 */
export function getMonthsBetween(startDate: string, endDate: string): string[] {
  const start = new Date(startDate);
  const end = new Date(endDate);
  const months: string[] = [];
  
  const current = new Date(start);
  current.setDate(1); // 월의 첫날로 설정
  
  while (current <= end) {
    const year = current.getFullYear();
    const month = (current.getMonth() + 1).toString().padStart(2, '0');
    months.push(`${year}-${month}`);
    
    current.setMonth(current.getMonth() + 1);
  }
  
  return months;
}

/**
 * YYYY-MM 형식의 문자열을 "YYYY년 M월" 형식으로 변환
 */
export function formatYearMonth(yearMonth: string): string {
  const [year, month] = yearMonth.split('-');
  return `${year}년 ${parseInt(month)}월`;
}
</file>
  <file path="lib/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function absoluteUrl(path: string) {
  return `${process.env.NEXT_PUBLIC_APP_URL || ""}${path}`
}

export function formatDate(input: string | number): string {
  const date = new Date(input)
  return date.toLocaleDateString("ko-KR", {
    month: "long",
    day: "numeric",
    year: "numeric",
  })
}

export function isValidUrl(url: string) {
  try {
    new URL(url)
    return true
  } catch (e) {
    return false
  }
}

export function getInitials(name: string) {
  return name
    .split(" ")
    .map((n) => n[0])
    .join("")
    .toUpperCase()
}

export function truncate(str: string, length: number) {
  return str.length > length ? `${str.substring(0, length)}...` : str
}

export function slugify(str: string) {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)+/g, "")
}

export function unslugify(str: string) {
  return str.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase())
}

export function wait(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms))
}

export function formatNumber(value: number) {
  return new Intl.NumberFormat("ko-KR").format(value)
}

export function formatCurrency(value: number) {
  return new Intl.NumberFormat("ko-KR", {
    style: "currency",
    currency: "KRW",
    currencyDisplay: "symbol",
    maximumFractionDigits: 0
  }).format(value)
}

export function formatDateString(dateString: string) {
  const date = new Date(dateString)
  return new Intl.DateTimeFormat("ko-KR", {
    year: "numeric",
    month: "long",
    day: "numeric"
  }).format(date)
}

export function formatDateTimeString(dateString: string) {
  const date = new Date(dateString)
  return new Intl.DateTimeFormat("ko-KR", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit"
  }).format(date)
}

export function getYearMonth() {
  const now = new Date()
  const year = now.getFullYear()
  const month = String(now.getMonth() + 1).padStart(2, "0")
  return `${year}-${month}`
}

export function getPreviousYearMonth() {
  const now = new Date()
  now.setMonth(now.getMonth() - 1)
  const year = now.getFullYear()
  const month = String(now.getMonth() + 1).padStart(2, "0")
  return `${year}-${month}`
}
</file>
  <file path="lib/supabase-admin.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseServiceKey) {
  console.error('Supabase URL 또는 Service Key가 설정되지 않았습니다. .env 파일을 확인하세요.');
  throw new Error('Supabase 환경 변수가 설정되지 않았습니다');
}

// 서비스 롤 키를 사용한 관리자 클라이언트 생성
export const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});
</file>
  <file path="lib/auth.ts">
import { NextRequest, NextResponse } from 'next/server';
import { auth as clerkAuth, currentUser } from '@clerk/nextjs/server';
import { db } from '@/db';
import { users, kols } from '@/db/schema';
import { eq } from 'drizzle-orm';
import { serverSupabase } from './supabase';
import { supabaseAdmin } from './supabase-admin';
import { cookies } from 'next/headers';

export type AuthUser = {
  id: string;
  email: string;
  role: string;
};

// 간단한 구현을 위해 Clerk 의존성 제거
export async function getCurrentUser(): Promise<AuthUser | null> {
  // 임시 구현: 실제 환경에서는 세션 등에서 사용자 ID를 가져와야 함
  const mockUserId = process.env.MOCK_USER_ID || null;
  
  if (!mockUserId) {
    return null;
  }

  return {
    id: mockUserId,
    email: 'user@example.com',
    role: 'user',
  };
}

export function isAuthenticated(request: NextRequest): boolean {
  const authHeader = request.headers.get('authorization');
  return !!authHeader && authHeader.startsWith('Bearer ');
}

export function isAdmin(user: AuthUser | null): boolean {
  return user?.role === 'admin';
}

export function isKOL(user: AuthUser | null): boolean {
  return user?.role === 'kol';
}

export function isUser(user: AuthUser | null): boolean {
  return user?.role === 'user';
}

export function hasAccess(user: AuthUser | null, requiredRoles: string[]): boolean {
  if (!user) return false;
  return requiredRoles.includes(user.role);
}

export function getAccessToken(request: NextRequest): string | null {
  const authHeader = request.headers.get('authorization');
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return null;
  }
  
  return authHeader.substring(7); // 'Bearer ' 이후의 토큰 부분
}

// 메모리 캐시 구현
const roleCache = new Map<string, { role: string | null, timestamp: number }>();
const CACHE_TTL = 60 * 1000; // 1분 캐시

/**
 * 클라이언트 컴포넌트(레이아웃 등)에서 사용할 사용자 역할 조회 함수
 * Clerk publicMetadata에서 역할을 가져옵니다.
 * 
 * @param clerkUserId Clerk 사용자 ID
 * @returns 사용자 역할 또는 null
 */
export async function getClientRole(clerkUserId: string | null): Promise<string | null> {
  if (!clerkUserId) {
    return null;
  }
  
  // 캐시에서 역할 확인
  const cachedData = roleCache.get(clerkUserId);
  const now = Date.now();
  
  if (cachedData && (now - cachedData.timestamp < CACHE_TTL)) {
    console.log('캐시된 사용자 역할 사용:', clerkUserId);
    return cachedData.role;
  }
  
  console.log('Clerk에서 사용자 역할 조회 중:', clerkUserId);
  try {
    // Clerk에서 현재 사용자 정보 가져오기
    const user = await currentUser();
    if (!user) {
      console.error('Clerk에서 사용자 정보를 찾을 수 없음:', clerkUserId);
      roleCache.set(clerkUserId, { role: null, timestamp: now });
      return null;
    }
    
    // Clerk publicMetadata에서 역할 가져오기
    const role = user.publicMetadata?.role as string | undefined;
    
    // 캐시 업데이트
    roleCache.set(clerkUserId, { role: role || null, timestamp: now });
    return role || null;
  } catch (error) {
    console.error('Clerk에서 사용자 역할 조회 중 오류:', error);
    return null;
  }
}

// [로그인 전용] Clerk를 통한 인증 함수
export async function getAuth(request?: NextRequest): Promise<{userId: string | null, role: string | null}> {
  try {
    // Clerk의 auth 사용하여 userId와 세션 정보 가져오기
    const { userId, sessionClaims } = await clerkAuth();
    
    if (!userId) {
      return { userId: null, role: null };
    }
    
    // Clerk 세션 정보에서 역할 확인
    const metadata = sessionClaims?.metadata as Record<string, unknown> || {};
    const role = metadata.role as string | undefined;
    
    return { userId, role: role || null };
  } catch (error) {
    console.error('인증 정보 확인 중 오류:', error);
    return { userId: null, role: null };
  }
}

/**
 * [로그인 전용] Clerk 기반 인증 검증 유틸리티 함수
 */
export async function checkAuth(
  request: NextRequest,
  allowedRoles?: string[]
): Promise<NextResponse | null> {
  try {
    // 사용자 인증 확인
    const { userId, role } = await getAuth();
    
    // 인증되지 않은 경우
    if (!userId) {
      console.error('인증되지 않은 사용자의 API 접근');
      return NextResponse.json(
        { error: "인증되지 않은 사용자입니다." },
        { status: 401 }
      );
    }
    
    // 역할 검증이 필요한 경우
    if (allowedRoles && allowedRoles.length > 0) {
      if (!role || !allowedRoles.includes(role)) {
        console.error(`권한 부족: 요청된 역할 ${role}, 필요한 역할 ${allowedRoles.join(', ')}`);
        return NextResponse.json(
          { error: "접근 권한이 없습니다." },
          { status: 403 }
        );
      }
    }
    
    // 인증 및 권한 검증 성공
    return null;
  } catch (error) {
    console.error('인증 검증 중 오류:', error);
    return NextResponse.json(
      { error: "인증 처리 중 오류가 발생했습니다." },
      { status: 500 }
    );
  }
}

/**
 * [모든 API용] Supabase를 통한 인증 함수
 * Supabase 세션을 사용하여 사용자의 인증 정보와 역할을 가져옵니다.
 * 
 * @returns 사용자 ID와 역할 정보
 */
export async function getAuthSupabase(): Promise<{userId: string | null, role: string | null, email: string | null}> {
  try {
    // Supabase에서 현재 사용자 정보 가져오기
    const { data: { user }, error } = await serverSupabase.auth.getUser();
    
    if (error || !user) {
      console.error('Supabase 사용자 정보 가져오기 실패:', error);
      return { userId: null, role: null, email: null };
    }
    
    // 사용자 이메일이 없는 경우
    if (!user.email) {
      console.error('Supabase 사용자 이메일이 없음:', user.id);
      return { userId: user.id, role: null, email: null };
    }
    
    // 사용자 이메일로 DB에서 역할 정보 조회
    const userInfo = await db.query.users.findFirst({
      where: eq(users.email, user.email),
    });
    
    if (!userInfo) {
      console.error('사용자 정보를 DB에서 찾을 수 없음:', user.email);
      return { userId: user.id, role: null, email: user.email };
    }
    
    return { 
      userId: user.id, 
      role: userInfo.role, 
      email: user.email 
    };
  } catch (error) {
    console.error('Supabase 인증 정보 확인 중 오류:', error);
    return { userId: null, role: null, email: null };
  }
}

/**
 * [모든 API용] Clerk와 DB를 사용한 인증 검증 유틸리티 함수
 * Supabase 세션 문제를 해결하기 위해 Clerk 인증을 사용하고 DB에서 직접 역할을 조회합니다.
 *
 * @param allowedRoles 허용할 역할 목록 (선택적)
 * @returns 응답 객체 또는 null (인증 성공 시)
 */
export async function checkAuthSupabase(
  allowedRoles?: string[]
): Promise<NextResponse | {userId: string, role: string, email: string} | null> {
  try {
    // Clerk에서 현재 사용자 정보 가져오기
    const user = await currentUser();

    // 인증되지 않은 경우
    if (!user || !user.emailAddresses || user.emailAddresses.length === 0) {
      console.error('인증되지 않은 사용자의 API 접근');
      return NextResponse.json(
        { error: "인증되지 않은 사용자입니다." },
        { status: 401 }
      );
    }

    // 사용자 기본 이메일 주소 가져오기
    const primaryEmail = user.emailAddresses[0].emailAddress;

    // DB에서 사용자 정보와 역할 조회
    const userInfo = await db.query.users.findFirst({
      where: eq(users.email, primaryEmail),
    });

    if (!userInfo) {
      console.error('사용자 정보를 DB에서 찾을 수 없음:', primaryEmail);
      return NextResponse.json(
        { error: "사용자 정보를 찾을 수 없습니다." },
        { status: 404 }
      );
    }

    // 역할 검증이 필요한 경우
    if (allowedRoles && allowedRoles.length > 0) {
      if (!userInfo.role || !allowedRoles.includes(userInfo.role)) {
        console.error(`권한 부족: 요청된 역할 ${userInfo.role}, 필요한 역할 ${allowedRoles.join(', ')}`);
        return NextResponse.json(
          { error: "접근 권한이 없습니다." },
          { status: 403 }
        );
      }
    }

    // 인증 및 권한 검증 성공 - 사용자 정보 반환
    return {
      userId: user.id,
      role: userInfo.role as string,
      email: primaryEmail
    };
  } catch (error) {
    console.error('인증 검증 중 오류:', error);
    return NextResponse.json(
      { error: "인증 처리 중 오류가 발생했습니다." },
      { status: 500 }
    );
  }
}

/**
 * KOL의 ID를 가져오는 유틸리티 함수
 * 
 * @param userId 사용자 ID
 * @returns KOL ID 또는 null
 */
export async function getKolId(userId: string): Promise<number | null> {
  try {
    // 사용자 정보 조회
    const userInfo = await db.query.users.findFirst({
      where: eq(users.clerkId, userId),
    });

    if (!userInfo) {
      return null;
    }

    // KOL 정보 조회
    const kol = await db.query.kols.findFirst({
      where: eq(kols.userId, userInfo.id),
    });

    return kol ? kol.id : null;
  } catch (error) {
    console.error('KOL ID 조회 중 오류:', error);
    return null;
  }
}

// 명시적으로 객체를 변수에 할당하여 ESLint 경고 해결
const authExports = {
  getCurrentUser,
  isAuthenticated,
  isAdmin,
  isKOL,
  isUser,
  hasAccess,
  getAccessToken,
  getAuth,
  checkAuth,
  getAuthSupabase,
  checkAuthSupabase,
  getKolId,
  getClientRole,
};

export default authExports;
</file>
  <file path="lib/supabase.ts">
import { createClient } from '@supabase/supabase-js';

// 환경 변수 체크 및 기본값 설정
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL ? process.env.NEXT_PUBLIC_SUPABASE_URL.trim() : '';
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ? process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY.trim() : '';
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY ? process.env.SUPABASE_SERVICE_ROLE_KEY.trim() : supabaseAnonKey;

// 환경 변수 로그 출력 (디버깅용)
if (typeof window === 'undefined') { // 서버 사이드에서만 실행
  console.log('Supabase URL:', supabaseUrl ? '설정됨' : '미설정');
  console.log('Supabase Anon Key:', supabaseAnonKey ? '설정됨' : '미설정');
  console.log('Supabase Service Key:', supabaseServiceKey ? '설정됨' : '미설정');
}

// URL 검증 함수
const isValidUrl = (url: string): boolean => {
  if (!url) return false;
  try {
    new URL(url);
    return true;
  } catch (e) {
    return false;
  }
};

// URL 검증 결과
const validSupabaseUrl = isValidUrl(supabaseUrl) 
  ? supabaseUrl 
  : 'https://placeholder-url.supabase.co';

const validSupabaseKey = supabaseAnonKey || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.placeholder';
const validServiceKey = supabaseServiceKey || validSupabaseKey;

if (!isValidUrl(supabaseUrl)) {
  console.error('⚠️ 유효하지 않은 Supabase URL입니다:', supabaseUrl);
  console.error('NEXT_PUBLIC_SUPABASE_URL 환경 변수를 확인해주세요.');
}

// 서버 사이드 전용 Supabase 클라이언트 (API 라우트에서 사용)
export const serverSupabase = createClient(validSupabaseUrl, validServiceKey, {
  auth: {
    persistSession: false,
    autoRefreshToken: false,
  },
  db: {
    schema: 'public',
  },
  global: {
    headers: {
      'X-Client-Info': 'biofox-kol-server',
    },
    fetch: async (...args) => {
      const [url, config] = args;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10초 타임아웃으로 단축

      try {
        // IPv4 강제 적용을 위한 URL 직접 수정
        let urlObj;
        try {
          urlObj = new URL(url.toString());
          // 수정된 부분: URL의 hostname이 IPv6 주소인 경우 처리
          if (urlObj.hostname.includes(':')) {
            console.log('IPv6 주소 감지, IPv4로 변환 시도');
            // Supabase URL이 있다면 그것을 사용
            if (validSupabaseUrl && validSupabaseUrl !== 'https://placeholder-url.supabase.co') {
              urlObj = new URL(validSupabaseUrl);
            }
          }
        } catch (e) {
          console.error('URL 파싱 오류:', e);
        }

        const customConfig = {
          ...config,
          signal: controller.signal,
          keepalive: true,
        };

        const response = await fetch(urlObj || url, customConfig);
        clearTimeout(timeoutId);
        return response;
      } catch (error: any) {
        if (error.name === 'AbortError') {
          throw new Error('Database connection timeout');
        }
        console.error('Supabase 연결 오류:', error);
        throw error;
      }
    },
  },
});

// 클라이언트 사이드 Supabase 클라이언트
export const supabase = createClient(validSupabaseUrl, validSupabaseKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
  },
  db: {
    schema: 'public',
  },
  global: {
    headers: {
      'X-Client-Info': 'biofox-kol-client',
    },
    fetch: async (...args) => {
      const [url, config] = args;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000); // 15초 타임아웃 (클라이언트는 더 짧게)

      try {
        // IPv4 강제 적용을 위한 URL 직접 수정
        let urlObj;
        try {
          urlObj = new URL(url.toString());
          // 수정된 부분: URL의 hostname이 IPv6 주소인 경우 처리
          if (urlObj.hostname.includes(':')) {
            console.log('IPv6 주소 감지, IPv4로 변환 시도');
            // Supabase URL이 있다면 그것을 사용
            if (validSupabaseUrl && validSupabaseUrl !== 'https://placeholder-url.supabase.co') {
              urlObj = new URL(validSupabaseUrl);
            }
          }
        } catch (e) {
          console.error('URL 파싱 오류:', e);
        }

        const customConfig = {
          ...config,
          signal: controller.signal,
          keepalive: true,
        };

        const response = await fetch(urlObj || url, customConfig);
        clearTimeout(timeoutId);
        return response;
      } catch (error: any) {
        if (error.name === 'AbortError') {
          throw new Error('Database connection timeout');
        }
        throw error;
      }
    },
  },
});

// 캐싱 설정 상수 (모든 API에서 공통으로 사용)
export const CACHE_SETTINGS = {
  REVALIDATE_TIME: 300, // 5분마다 재검증
  CACHE_CONTROL_HEADER: 'public, max-age=300, s-maxage=300, stale-while-revalidate=60',
};

// 타임스탬프 형식의 현재 날짜를 YYYY-MM 형식으로 반환
export function getCurrentYearMonth(): string {
  const date = new Date();
  return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
}

// Supabase 쿼리 결과를 카멜케이스로 변환하는 유틸리티 함수
export function snakeToCamel(obj: any): any {
  if (obj === null || obj === undefined || typeof obj !== 'object') {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(snakeToCamel);
  }

  return Object.keys(obj).reduce((acc, key) => {
    const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
    acc[camelKey] = snakeToCamel(obj[key]);
    return acc;
  }, {} as any);
}
</file>
</code>