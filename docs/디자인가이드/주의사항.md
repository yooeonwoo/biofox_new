# 디자인 시스템 마이그레이션 및 구현 가이드

이 문서는 기존 프로젝트에 새로운 디자인 시스템을 적용할 때 고려해야 할 주의사항과 단계별 마이그레이션 전략을 제공합니다. 기존 코드의 호환성을 유지하면서 점진적으로 새 디자인을 적용하는 방법에 중점을 둡니다.

> **중요**: 이 가이드에 포함된 모든 코드 예시는 참고용이며, 실제 구현 시에는 반드시 현재 프로젝트의 구조, 컨벤션, 요구사항에 맞게 수정해야 합니다. 예시 코드를 그대로 복사하여 사용하면 기존 프로젝트와 호환성 문제가 발생할 수 있습니다.

## 1. 호환성 유지를 위한 주요 원칙

### 1.1 CSS 변수 구조 유지

기존 CSS 변수 이름과 구조를 최대한 유지하여 호환성 문제를 방지합니다.

```css
/* 참고용 예시 - 프로젝트에 맞게 수정 필요 */
:root {
  --background: #ffffff; /* 기존 변수 유지 */
  --foreground: #171717; /* 기존 변수 유지 */
  
  /* 새 변수는 추가로 정의 */
  --dark-gray-1: #383844;
  --dark-gray-2: #2E3035;
}

/* 아래와 같은 방식은 지양해야 함 */
:root {
  --bg-color: #ffffff; /* 변경된 이름 - 기존 코드에서 문제 발생 */
  --text-color: #171717; /* 변경된 이름 - 기존 코드에서 문제 발생 */
}
```

> **주의**: 위 코드는 일반적인 예시일 뿐입니다. 실제 프로젝트의 CSS 변수 구조를 분석하고 그에 맞게 변수를 유지해야 합니다.
```

### 1.2 클래스 네이밍 충돌 방지

새로운 클래스와 기존 클래스 간 충돌을 방지합니다.

```css
/* 참고용 예시 - 프로젝트의 명명 규칙에 맞게 조정 필요 */
.ds-btn-primary { /* 네임스페이스 접두사로 분리 */
  background-color: var(--primary-color);
}

/* 기존 클래스는 그대로 유지하고 새 스타일을 오버라이드 */
.btn-primary {
  /* 프로젝트의 기존 스타일 구조를 분석한 후 수정 */
}
```

> **중요**: 위 네이밍 패턴은 예시일 뿐입니다. 프로젝트에서 사용 중인 CSS 방법론(BEM, SMACSS 등)이나 컨벤션에 맞춰 일관성 있게 적용해야 합니다.
```

### 1.3 컴포넌트 속성 유지

기존 컴포넌트의 props(속성) 구조를 유지하면서 새 디자인을 적용합니다.

```tsx
// 참고용 예시 - 프로젝트의 컴포넌트 구조에 맞게 조정 필요
function Button({ variant = "default", size = "default", className, ...props }) {
  // 프로젝트의 기존 Button 컴포넌트 구현 방식에 맞게 수정
  return <button 
    className={cn(
      // 실제 프로젝트의 클래스 결합 로직에 맞춰 수정 필요
    )} 
    {...props} 
  />;
}

// 지양해야 할 방식
function Button({ style = "primary", dimension = "medium", ...props }) {
  // 프로퍼티 이름 변경은 기존 코드 호환성 문제 발생
}
```

> **주의**: 각 컴포넌트의 기존 props와 인터페이스를 철저히 분석한 후 수정해야 합니다. 위 코드는 단순 예시일 뿐입니다.
```

## 2. 단계별 마이그레이션 전략

### 2.1 병렬 디자인 시스템 접근법

기존 시스템과 새 시스템을 일정 기간 병렬로 유지하는 전략입니다.

1. **색상 시스템 마이그레이션**
   ```js
   // 참고용 예시 - tailwind.config.js 파일 구조에 맞게 수정 필요
   module.exports = {
     theme: {
       extend: {
         colors: {
           // 기존 색상 변수에 맞게 매핑
           'primary': 'var(--your-primary-color)',
           'secondary': 'var(--your-secondary-color)',
           
           // 새 색상 추가 - 실제 변수명에 맞게 수정
           'dark-gray-1': 'var(--your-dark-gray-1)',
           'aurora-pink': 'var(--your-pink-color)',
         }
       }
     }
   }
   ```

2. **코드 분기(Branching) 없는 통합**
   ```tsx
   // 참고용 예시 - 프로젝트의 컴포넌트 구조에 맞게 조정
   const buttonVariants = cva(
     "base-button-styles", // 프로젝트의 기본 스타일로 변경
     {
       variants: {
         variant: {
           // 기존 변형 - 실제 프로젝트 네이밍에 맞게 수정
           primary: "프로젝트의-기존-스타일-클래스",
           secondary: "프로젝트의-기존-스타일-클래스",
           
           // 새 변형 - 기존 이름과 충돌하지 않게 주의
           newDefault: "새로운-스타일-클래스",
           newOutline: "새로운-스타일-클래스",
         }
       }
     }
   )
   ```

> **중요**: 위 코드 예시는 개념을 설명하기 위한 것일 뿐입니다. 실제 구현 시에는 현재 프로젝트의 Tailwind 설정, 컴포넌트 구조, 네이밍 규칙에 맞게 조정해야 합니다.
   ```

### 2.2 점진적 마이그레이션 순서

1. **기본 변수 및 설정 파일 업데이트**
   - `globals.css` 파일에 새 변수 추가 (기존 변수 유지)
   - Tailwind 설정 확장 (기존 설정 유지)

2. **공통 유틸리티 클래스 도입**
   - 애니메이션, 반응형, 그림자 등 공통 유틸리티 클래스 추가

3. **핵심 컴포넌트 업데이트**
   - 가장 기본적인 UI 컴포넌트부터 시작
   - 각 컴포넌트에 새 스타일 옵션 추가 (기존 옵션 유지)

4. **페이지 단위 점진적 적용**
   - 신규 페이지에는 완전히 새 디자인 적용
   - 기존 페이지는 중요도/사용빈도에 따라 순차적 마이그레이션

> **프로젝트 맞춤화**: 위 순서는 일반적인 접근법이며, 프로젝트의 특성, 팀 구조, 우선순위에 따라 조정이 필요합니다. 마이그레이션 계획 수립 시 프로젝트의 구체적인 상황을 고려해야 합니다.

## 3. 컴포넌트별 마이그레이션 주의사항

### 3.1 Button 컴포넌트

```tsx
// 참고용 예시 - 프로젝트의 Button 컴포넌트 구조에 맞게 수정 필요
// 1. 기존 variants 유지하면서 새 variants 추가
const buttonVariants = cva(
  "base-styles", // 프로젝트의 기본 스타일로 대체
  {
    variants: {
      variant: {
        // 기존 variant 매핑 - 프로젝트의 실제 이름과 스타일로 대체
        // 예: default, primary, secondary 등
        
        // 새 variant 추가 - 이름 충돌에 주의
        // 예: gradient, modern, glass 등
      },
      // size 등 다른 속성도 동일한 접근법
    }
  }
);

// 2. 내부 구현 변경 시 기존 코드 작동 확인
// 프로젝트의 Button 컴포넌트 구현 방식에 맞게 수정
```

> **주의**: 위 예시는 개념적인 구조를 보여주는 것일 뿐입니다. 실제 구현 시에는 프로젝트의 Button 컴포넌트 구조를 면밀히 분석한 후, 그에 맞는 방식으로 수정해야 합니다.

### 3.2 Card 컴포넌트

```tsx
// 참고용 예시 - 프로젝트의 Card 컴포넌트 구조에 맞게 수정 필요
// 1. 스타일 확장 접근법 - 기본 스타일은 유지하고 새 스타일은 옵션으로 제공
function Card({ variant = "default", className, ...props }) {
  // variantStyles 객체는 프로젝트의 기존 스타일 체계에 맞게 조정 필요
  const variantStyles = {
    default: "프로젝트-기존-카드-스타일",
    // 새로운 스타일 옵션 추가
  };
  
  // 클래스 결합 로직은 프로젝트의 유틸리티 함수에 맞게 조정
  return <div className={/* 프로젝트에 맞는 방식으로 구현 */} {...props} />;
}
```

> **참고**: 실제 구현 시에는 프로젝트의 Card 컴포넌트가 사용하는 속성(props), 스타일링 방식, 클래스 결합 로직 등을 정확히 파악하여 적용해야 합니다. 위 코드는 단순 예시입니다.
```

### 3.3 Alert, Dialog 등 복합 컴포넌트

```tsx
// 참고용 예시 - 프로젝트의 Alert/Dialog 컴포넌트 구조에 맞게 수정 필요
// 1. 하위 컴포넌트 일관성 유지
function Alert({ variant = "default", className, ...props }) {
  // alertVariants와 cn 함수는 프로젝트의 실제 구현에 맞게 수정
  return <div className={/* 프로젝트에 맞는 방식으로 구현 */} {...props} />;
}

// Alert.Title 등의 하위 컴포넌트는 프로젝트의 구조를 철저히 분석한 후 수정
Alert.Title = function AlertTitle({ className, ...props }) {
  // 프로젝트의 기존 구현 방식과 일치하도록 수정
  return <h5 className={/* 프로젝트에 맞는 방식으로 구현 */} {...props} />;
};

// 2. Context API를 사용하는 컴포넌트 관련 주의사항
// Dialog와 같은 컴포넌트는 내부 상태 관리 방식에 따라 다를 수 있음
// 프로젝트의 기존 구현 방식을 면밀히 분석할 것
```

> **중요**: 복합 컴포넌트(Compound Components)는 프로젝트마다 구현 방식이 크게 다를 수 있습니다. 위 코드는 일반적인 패턴을 보여주는 예시일 뿐이며, 실제 구현 시에는 프로젝트의 컴포넌트 구조, 상태 관리 방식, 이벤트 처리 방식 등을 철저히 분석해야 합니다.

## 4. globals.css 마이그레이션 가이드

```css
/* 참고용 예시 - 프로젝트의 CSS 구조에 맞게 수정 필요 */

/* 1. 섹션별 구분하여 마이그레이션 */

/* 기존 변수 섹션 - 프로젝트의 실제 변수명으로 대체 */
:root {
  --background: #ffffff; /* 프로젝트의 실제 변수명과 값으로 대체 */
  --foreground: #171717; /* 프로젝트의 실제 변수명과 값으로 대체 */
  /* 기존 변수 유지 */
}

/* 새 변수 섹션 - 명확히 구분 */
:root {
  /* 새 색상 시스템 - 프로젝트에 맞는 변수명과 값으로 대체 */
  --dark-gray-1: #383844; /* 예시 값 - 실제 디자인에 맞게 조정 */
  --aurora-pink: #FF8AE2; /* 예시 값 - 실제 디자인에 맞게 조정 */
  
  /* 그라데이션 및 효과 - 프로젝트에 맞게 조정 */
  --gradient-primary: linear-gradient(...); /* 실제 그라데이션 값으로 대체 */
  --shadow-glow: 0 0 15px rgba(...); /* 실제 그림자 값으로 대체 */
}
```

> **주의**: CSS 변수 구조는 프로젝트마다 크게 다를 수 있습니다. 위 예시는 일반적인 구조를 보여주는 것일 뿐이며, 실제 구현 시에는 프로젝트의 CSS 아키텍처와 변수 명명 규칙에 맞춰 조정해야 합니다.

/* 2. 새 클래스와 기존 클래스 공존 */

/* 기존 버튼 클래스 - 유지하되 내부 구현 개선 */
.btn-primary {
  background-color: var(--biofox-purple);
  color: white;
  padding: 0.5rem 1.5rem;
  border-radius: 0.5rem;
  font-weight: 600;
  transition: all 0.3s;
}

/* 새 버튼 클래스 - 별도 이름으로 추가 */
.ds-button-gradient {
  background-image: var(--gradient-primary);
  color: white;
  padding: 0.5rem 1.5rem;
  border-radius: 0.5rem;
  font-weight: 600;
  transition: all 0.3s;
}
```

## 5. 테스트 전략

### 5.1 회귀 테스트 중점 영역

1. **레이아웃 깨짐(Layout Shift)**
   - 컴포넌트 크기 및 여백 변경으로 인한 레이아웃 변화 테스트
   - 반응형 중단점(breakpoint)에서의 동작 확인

2. **기능 동작 확인**
   - 이벤트 핸들러와 상호작용이 제대로 작동하는지 확인
   - 폼 제출, 모달 작동 등 핵심 기능 테스트

3. **접근성(Accessibility)**
   - 색상 대비, 키보드 내비게이션 등 접근성 저하 여부 확인
   - 스크린 리더 호환성 테스트

### 5.2 테스트 자동화

```tsx
// 컴포넌트 테스트 예시 (Jest/React Testing Library)
describe('Button Component', () => {
  it('기존 스타일이 여전히 작동함', () => {
    const { getByRole } = render(<Button variant="default">Click me</Button>);
    const button = getByRole('button');
    expect(button).toHaveClass('contains-expected-class');
  });
  
  it('새 variant가 적용됨', () => {
    const { getByRole } = render(<Button variant="gradient">Click me</Button>);
    const button = getByRole('button');
    expect(button).toHaveClass('contains-gradient-class');
  });
  
  it('이벤트 핸들러가 여전히 작동함', () => {
    const handleClick = jest.fn();
    const { getByRole } = render(
      <Button onClick={handleClick}>Click me</Button>
    );
    fireEvent.click(getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

## 6. 문서화 및 개발자 가이드

### 6.1 컴포넌트 문서화

```tsx
/**
 * 버튼 컴포넌트
 * 
 * @deprecated variant="primary" - 대신 variant="default" 사용 (v2.0부터 제거 예정)
 * @param {Object} props
 * @param {string} [props.variant="default"] - 버튼 스타일 (default, secondary, outline, gradient)
 * @param {string} [props.size="default"] - 버튼 크기 (sm, default, lg)
 * @param {boolean} [props.isLoading] - 로딩 상태 표시
 * @param {ReactNode} props.children - 버튼 내용
 */
export function Button({ variant = "default", size = "default", isLoading, children, ...props }) {
  // 구현
}
```

### 6.2 마이그레이션 단계별 체크리스트

1. **초기 계획 단계**
   - [ ] 현재 컴포넌트 props와 사용 패턴 파악
   - [ ] 새 디자인 시스템과의 차이점 분석
   - [ ] 가장 많이 사용되는 컴포넌트 식별

2. **기반 작업**
   - [ ] CSS 변수 확장 및 Tailwind 설정 업데이트
   - [ ] 추가 애니메이션 및 유틸리티 클래스 정의
   - [ ] 기본 스타일 오버라이드 없는지 확인

3. **컴포넌트 마이그레이션**
   - [ ] 공통 컴포넌트부터 순차적 업데이트 (Button, Card, Alert 등)
   - [ ] 각 컴포넌트별 테스트 케이스 작성 및 실행
   - [ ] 반응형 동작 확인

4. **검증 및 배포**
   - [ ] 스테이징 환경에서 통합 테스트
   - [ ] 성능 영향 측정 (번들 크기, 페이지 로드 시간)
   - [ ] 점진적 배포 및 모니터링

## 7. 추가 고려사항

### 7.1 번들 크기 최적화

새 디자인 시스템 추가로 인한 CSS와 JavaScript 번들 크기 증가에 주의합니다.

```js
// tailwind.config.js에서 미사용 스타일 제거
module.exports = {
  purge: [
    './src/**/*.{js,jsx,ts,tsx}',
  ],
  // 또는 최신 Tailwind 버전에서:
  content: [
    './src/**/*.{js,jsx,ts,tsx}',
  ],
}
```

### 7.2 성능 영향 고려

그라데이션 및 블러 효과가 성능에 미치는 영향을 고려하고 최적화합니다.

```css
/* 성능 고려한 애니메이션 */
.animate-gradient {
  /* GPU 가속 활용 */
  transform: translateZ(0);
  will-change: background-position;
  background-size: 200% 200%;
  animation: gradient-shift 8s ease infinite;
}

/* 저사양 기기 고려 (media query) */
@media (prefers-reduced-motion: reduce) {
  .animate-gradient {
    animation: none;
    background-position: 0% 50%;
  }
}
```

### 7.3 브라우저 호환성

최신 CSS 기능의 브라우저 호환성을 확인하고 필요시 대체 스타일을 제공합니다.

```css
/* backdrop-filter에 대한 대체 스타일 */
.glass {
  /* 모던 브라우저용 */
  background: rgba(56, 56, 68, 0.6);
  backdrop-filter: blur(12px);
  
  /* 대체 스타일 (backdrop-filter 미지원) */
  @supports not (backdrop-filter: blur(12px)) {
    background: rgba(56, 56, 68, 0.9);
  }
}
```

## 8. 결론

기존 프로젝트에 새 디자인 시스템을 적용할 때는 점진적인 접근 방식이 중요합니다. 기존 코드의 호환성을 유지하면서 새로운 디자인을 도입하는 것이 핵심입니다. 이 가이드를 따라 단계적으로 마이그레이션을 진행하면 리스크를 최소화하면서 디자인 시스템을 현대화할 수 있습니다.

마이그레이션은 코드 변경뿐만 아니라 개발팀 전체의 이해와 협력이 필요한 과정입니다. 문서화와 커뮤니케이션을 통해 모든 팀원이 변화를 이해하고 적응할 수 있도록 지원해야 합니다.


```css
/* 2. 새 클래스와 기존 클래스 공존 */

/* 기존 버튼 클래스 - 프로젝트의 실제 클래스명과 스타일로 대체 */
.btn-primary {
  /* 프로젝트의 기존 스타일을 유지하면서 필요한 부분만 수정 */
}

/* 새 버튼 클래스 - 프로젝트의 명명 규칙에 맞게 조정 */
.new-button-gradient {
  /* 새로운 디자인에 맞는 스타일 정의 */
}
```

> **주의**: CSS 클래스 구조는 프로젝트의 CSS 방법론(BEM, SMACSS, OOCSS 등)에 따라 크게 달라질 수 있습니다. 위 예시는 단순한 구조를 보여주는 것일 뿐이며, 실제 구현 시에는 프로젝트의 CSS 아키텍처와 컨벤션을 존중해야 합니다.

## 5. 테스트 전략

### 5.1 회귀 테스트 중점 영역

1. **레이아웃 깨짐(Layout Shift)**
   - 컴포넌트 크기 및 여백 변경으로 인한 레이아웃 변화 테스트
   - 반응형 중단점(breakpoint)에서의 동작 확인

2. **기능 동작 확인**
   - 이벤트 핸들러와 상호작용이 제대로 작동하는지 확인
   - 폼 제출, 모달 작동 등 핵심 기능 테스트

3. **접근성(Accessibility)**
   - 색상 대비, 키보드 내비게이션 등 접근성 저하 여부 확인
   - 스크린 리더 호환성 테스트

### 5.2 테스트 자동화

```tsx
// 참고용 예시 - 프로젝트의 테스트 환경과 방식에 맞게 수정 필요

// 컴포넌트 테스트 - Jest/React Testing Library 사용 예시
describe('Button 컴포넌트', () => {
  it('기존 스타일이 여전히 작동함', () => {
    // 프로젝트의 실제 테스트 방식으로 대체 필요
  });
  
  it('새 variant가 적용됨', () => {
    // 프로젝트의 실제 테스트 방식으로 대체 필요
  });
  
  it('이벤트 핸들러가 여전히 작동함', () => {
    // 프로젝트의 실제 테스트 방식으로 대체 필요
  });
});
```

> **중요**: 프로젝트에서 사용 중인 테스트 프레임워크(Jest, Vitest, Cypress 등)와 테스트 패턴에 맞게 실제 테스트 코드를 작성해야 합니다. 위 코드는 단순 예시입니다.
# 디자인 시스템 마이그레이션 및 구현 가이드

이 문서는 기존 프로젝트에 새로운 디자인 시스템을 적용할 때 고려해야 할 주의사항과 단계별 마이그레이션 전략을 제공합니다. 기존 코드의 호환성을 유지하면서 점진적으로 새 디자인을 적용하는 방법에 중점을 둡니다.

> **중요**: 이 가이드에 포함된 모든 코드 예시는 참고용이며, 실제 구현 시에는 반드시 현재 프로젝트의 구조, 컨벤션, 요구사항에 맞게 수정해야 합니다. 예시 코드를 그대로 복사하여 사용하면 기존 프로젝트와 호환성 문제가 발생할 수 있습니다.

## 1. 호환성 유지를 위한 주요 원칙

### 1.1 CSS 변수 구조 유지

기존 CSS 변수 이름과 구조를 최대한 유지하여 호환성 문제를 방지합니다.

```css
/* 참고용 예시 - 프로젝트에 맞게 수정 필요 */
:root {
  --background: #ffffff; /* 기존 변수 유지 */
  --foreground: #171717; /* 기존 변수 유지 */
  
  /* 새 변수는 추가로 정의 */
  --dark-gray-1: #383844;
  --dark-gray-2: #2E3035;
}

/* 아래와 같은 방식은 지양해야 함 */
:root {
  --bg-color: #ffffff; /* 변경된 이름 - 기존 코드에서 문제 발생 */
  --text-color: #171717; /* 변경된 이름 - 기존 코드에서 문제 발생 */
}
```

> **주의**: 위 코드는 일반적인 예시일 뿐입니다. 실제 프로젝트의 CSS 변수 구조를 분석하고 그에 맞게 변수를 유지해야 합니다.
```

### 1.2 클래스 네이밍 충돌 방지

새로운 클래스와 기존 클래스 간 충돌을 방지합니다.

```css
/* 참고용 예시 - 프로젝트의 명명 규칙에 맞게 조정 필요 */
.ds-btn-primary { /* 네임스페이스 접두사로 분리 */
  background-color: var(--primary-color);
}

/* 기존 클래스는 그대로 유지하고 새 스타일을 오버라이드 */
.btn-primary {
  /* 프로젝트의 기존 스타일 구조를 분석한 후 수정 */
}
```

> **중요**: 위 네이밍 패턴은 예시일 뿐입니다. 프로젝트에서 사용 중인 CSS 방법론(BEM, SMACSS 등)이나 컨벤션에 맞춰 일관성 있게 적용해야 합니다.
```

### 1.3 컴포넌트 속성 유지

기존 컴포넌트의 props(속성) 구조를 유지하면서 새 디자인을 적용합니다.

```tsx
// 참고용 예시 - 프로젝트의 컴포넌트 구조에 맞게 조정 필요
function Button({ variant = "default", size = "default", className, ...props }) {
  // 프로젝트의 기존 Button 컴포넌트 구현 방식에 맞게 수정
  return <button 
    className={cn(
      // 실제 프로젝트의 클래스 결합 로직에 맞춰 수정 필요
    )} 
    {...props} 
  />;
}

// 지양해야 할 방식
function Button({ style = "primary", dimension = "medium", ...props }) {
  // 프로퍼티 이름 변경은 기존 코드 호환성 문제 발생
}
```

> **주의**: 각 컴포넌트의 기존 props와 인터페이스를 철저히 분석한 후 수정해야 합니다. 위 코드는 단순 예시일 뿐입니다.
```

## 2. 단계별 마이그레이션 전략

### 2.1 병렬 디자인 시스템 접근법

기존 시스템과 새 시스템을 일정 기간 병렬로 유지하는 전략입니다.

1. **색상 시스템 마이그레이션**
   ```js
   // 참고용 예시 - tailwind.config.js 파일 구조에 맞게 수정 필요
   module.exports = {
     theme: {
       extend: {
         colors: {
           // 기존 색상 변수에 맞게 매핑
           'primary': 'var(--your-primary-color)',
           'secondary': 'var(--your-secondary-color)',
           
           // 새 색상 추가 - 실제 변수명에 맞게 수정
           'dark-gray-1': 'var(--your-dark-gray-1)',
           'aurora-pink': 'var(--your-pink-color)',
         }
       }
     }
   }
   ```

2. **코드 분기(Branching) 없는 통합**
   ```tsx
   // 참고용 예시 - 프로젝트의 컴포넌트 구조에 맞게 조정
   const buttonVariants = cva(
     "base-button-styles", // 프로젝트의 기본 스타일로 변경
     {
       variants: {
         variant: {
           // 기존 변형 - 실제 프로젝트 네이밍에 맞게 수정
           primary: "프로젝트의-기존-스타일-클래스",
           secondary: "프로젝트의-기존-스타일-클래스",
           
           // 새 변형 - 기존 이름과 충돌하지 않게 주의
           newDefault: "새로운-스타일-클래스",
           newOutline: "새로운-스타일-클래스",
         }
       }
     }
   )
   ```

> **중요**: 위 코드 예시는 개념을 설명하기 위한 것일 뿐입니다. 실제 구현 시에는 현재 프로젝트의 Tailwind 설정, 컴포넌트 구조, 네이밍 규칙에 맞게 조정해야 합니다.
   ```

### 2.2 점진적 마이그레이션 순서

1. **기본 변수 및 설정 파일 업데이트**
   - `globals.css` 파일에 새 변수 추가 (기존 변수 유지)
   - Tailwind 설정 확장 (기존 설정 유지)

2. **공통 유틸리티 클래스 도입**
   - 애니메이션, 반응형, 그림자 등 공통 유틸리티 클래스 추가

3. **핵심 컴포넌트 업데이트**
   - 가장 기본적인 UI 컴포넌트부터 시작
   - 각 컴포넌트에 새 스타일 옵션 추가 (기존 옵션 유지)

4. **페이지 단위 점진적 적용**
   - 신규 페이지에는 완전히 새 디자인 적용
   - 기존 페이지는 중요도/사용빈도에 따라 순차적 마이그레이션

> **프로젝트 맞춤화**: 위 순서는 일반적인 접근법이며, 프로젝트의 특성, 팀 구조, 우선순위에 따라 조정이 필요합니다. 마이그레이션 계획 수립 시 프로젝트의 구체적인 상황을 고려해야 합니다.

## 3. 컴포넌트별 마이그레이션 주의사항

### 3.1 Button 컴포넌트

```tsx
// 참고용 예시 - 프로젝트의 Button 컴포넌트 구조에 맞게 수정 필요
// 1. 기존 variants 유지하면서 새 variants 추가
const buttonVariants = cva(
  "base-styles", // 프로젝트의 기본 스타일로 대체
  {
    variants: {
      variant: {
        // 기존 variant 매핑 - 프로젝트의 실제 이름과 스타일로 대체
        // 예: default, primary, secondary 등
        
        // 새 variant 추가 - 이름 충돌에 주의
        // 예: gradient, modern, glass 등
      },
      // size 등 다른 속성도 동일한 접근법
    }
  }
);

// 2. 내부 구현 변경 시 기존 코드 작동 확인
// 프로젝트의 Button 컴포넌트 구현 방식에 맞게 수정
```

> **주의**: 위 예시는 개념적인 구조를 보여주는 것일 뿐입니다. 실제 구현 시에는 프로젝트의 Button 컴포넌트 구조를 면밀히 분석한 후, 그에 맞는 방식으로 수정해야 합니다.

### 3.2 Card 컴포넌트

```tsx
// 참고용 예시 - 프로젝트의 Card 컴포넌트 구조에 맞게 수정 필요
// 1. 스타일 확장 접근법 - 기본 스타일은 유지하고 새 스타일은 옵션으로 제공
function Card({ variant = "default", className, ...props }) {
  // variantStyles 객체는 프로젝트의 기존 스타일 체계에 맞게 조정 필요
  const variantStyles = {
    default: "프로젝트-기존-카드-스타일",
    // 새로운 스타일 옵션 추가
  };
  
  // 클래스 결합 로직은 프로젝트의 유틸리티 함수에 맞게 조정
  return <div className={/* 프로젝트에 맞는 방식으로 구현 */} {...props} />;
}
```

> **참고**: 실제 구현 시에는 프로젝트의 Card 컴포넌트가 사용하는 속성(props), 스타일링 방식, 클래스 결합 로직 등을 정확히 파악하여 적용해야 합니다. 위 코드는 단순 예시입니다.
```

### 3.3 Alert, Dialog 등 복합 컴포넌트

```tsx
// 참고용 예시 - 프로젝트의 Alert/Dialog 컴포넌트 구조에 맞게 수정 필요
// 1. 하위 컴포넌트 일관성 유지
function Alert({ variant = "default", className, ...props }) {
  // alertVariants와 cn 함수는 프로젝트의 실제 구현에 맞게 수정
  return <div className={/* 프로젝트에 맞는 방식으로 구현 */} {...props} />;
}

// Alert.Title 등의 하위 컴포넌트는 프로젝트의 구조를 철저히 분석한 후 수정
Alert.Title = function AlertTitle({ className, ...props }) {
  // 프로젝트의 기존 구현 방식과 일치하도록 수정
  return <h5 className={/* 프로젝트에 맞는 방식으로 구현 */} {...props} />;
};

// 2. Context API를 사용하는 컴포넌트 관련 주의사항
// Dialog와 같은 컴포넌트는 내부 상태 관리 방식에 따라 다를 수 있음
// 프로젝트의 기존 구현 방식을 면밀히 분석할 것
```

> **중요**: 복합 컴포넌트(Compound Components)는 프로젝트마다 구현 방식이 크게 다를 수 있습니다. 위 코드는 일반적인 패턴을 보여주는 예시일 뿐이며, 실제 구현 시에는 프로젝트의 컴포넌트 구조, 상태 관리 방식, 이벤트 처리 방식 등을 철저히 분석해야 합니다.

## 4. globals.css 마이그레이션 가이드

```css
/* 참고용 예시 - 프로젝트의 CSS 구조에 맞게 수정 필요 */

/* 1. 섹션별 구분하여 마이그레이션 */

/* 기존 변수 섹션 - 프로젝트의 실제 변수명으로 대체 */
:root {
  --background: #ffffff; /* 프로젝트의 실제 변수명과 값으로 대체 */
  --foreground: #171717; /* 프로젝트의 실제 변수명과 값으로 대체 */
  /* 기존 변수 유지 */
}

/* 새 변수 섹션 - 명확히 구분 */
:root {
  /* 새 색상 시스템 - 프로젝트에 맞는 변수명과 값으로 대체 */
  --dark-gray-1: #383844; /* 예시 값 - 실제 디자인에 맞게 조정 */
  --aurora-pink: #FF8AE2; /* 예시 값 - 실제 디자인에 맞게 조정 */
  
  /* 그라데이션 및 효과 - 프로젝트에 맞게 조정 */
  --gradient-primary: linear-gradient(...); /* 실제 그라데이션 값으로 대체 */
  --shadow-glow: 0 0 15px rgba(...); /* 실제 그림자 값으로 대체 */
}
```

> **주의**: CSS 변수 구조는 프로젝트마다 크게 다를 수 있습니다. 위 예시는 일반적인 구조를 보여주는 것일 뿐이며, 실제 구현 시에는 프로젝트의 CSS 아키텍처와 변수 명명 규칙에 맞춰 조정해야 합니다.

/* 2. 새 클래스와 기존 클래스 공존 */

/* 기존 버튼 클래스 - 유지하되 내부 구현 개선 */
.btn-primary {
  background-color: var(--biofox-purple);
  color: white;
  padding: 0.5rem 1.5rem;
  border-radius: 0.5rem;
  font-weight: 600;
  transition: all 0.3s;
}

/* 새 버튼 클래스 - 별도 이름으로 추가 */
.ds-button-gradient {
  background-image: var(--gradient-primary);
  color: white;
  padding: 0.5rem 1.5rem;
  border-radius: 0.5rem;
  font-weight: 600;
  transition: all 0.3s;
}
```

## 5. 테스트 전략

### 5.1 회귀 테스트 중점 영역

1. **레이아웃 깨짐(Layout Shift)**
   - 컴포넌트 크기 및 여백 변경으로 인한 레이아웃 변화 테스트
   - 반응형 중단점(breakpoint)에서의 동작 확인

2. **기능 동작 확인**
   - 이벤트 핸들러와 상호작용이 제대로 작동하는지 확인
   - 폼 제출, 모달 작동 등 핵심 기능 테스트

3. **접근성(Accessibility)**
   - 색상 대비, 키보드 내비게이션 등 접근성 저하 여부 확인
   - 스크린 리더 호환성 테스트

### 5.2 테스트 자동화

```tsx
// 컴포넌트 테스트 예시 (Jest/React Testing Library)
describe('Button Component', () => {
  it('기존 스타일이 여전히 작동함', () => {
    const { getByRole } = render(<Button variant="default">Click me</Button>);
    const button = getByRole('button');
    expect(button).toHaveClass('contains-expected-class');
  });
  
  it('새 variant가 적용됨', () => {
    const { getByRole } = render(<Button variant="gradient">Click me</Button>);
    const button = getByRole('button');
    expect(button).toHaveClass('contains-gradient-class');
  });
  
  it('이벤트 핸들러가 여전히 작동함', () => {
    const handleClick = jest.fn();
    const { getByRole } = render(
      <Button onClick={handleClick}>Click me</Button>
    );
    fireEvent.click(getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

## 6. 문서화 및 개발자 가이드

### 6.1 컴포넌트 문서화

```tsx
// 참고용 예시 - 프로젝트의 문서화 표준에 맞게 수정 필요
/**
 * 버튼 컴포넌트
 * 
 * @deprecated variant="이전_스타일명" - 대신 variant="새_스타일명" 사용 (미래 버전에서 제거 예정)
 * @param {Object} props - 프로젝트의 실제 타입 시스템에 맞게 조정 필요
 * @param {string} [props.variant="default"] - 버튼 스타일
 * @param {string} [props.size="default"] - 버튼 크기
 * @param {boolean} [props.isLoading] - 로딩 상태 표시
 * @param {ReactNode} props.children - 버튼 내용
 */
export function Button({ 
  // 프로젝트의 실제 컴포넌트 구조에 맞게 파라미터 조정
}) {
  // 구현
}
```

> **주의**: 위 JSDoc 형식은 예시일 뿐입니다. 프로젝트에서 사용 중인 문서화 방식(TypeScript 인터페이스, PropTypes, Storybook 등)에 맞게 조정해야 합니다.

### 6.2 마이그레이션 단계별 체크리스트

1. **초기 계획 단계**
   - [ ] 현재 컴포넌트 props와 사용 패턴 파악
   - [ ] 새 디자인 시스템과의 차이점 분석
   - [ ] 가장 많이 사용되는 컴포넌트 식별

2. **기반 작업**
   - [ ] CSS 변수 확장 및 Tailwind 설정 업데이트
   - [ ] 추가 애니메이션 및 유틸리티 클래스 정의
   - [ ] 기본 스타일 오버라이드 없는지 확인

3. **컴포넌트 마이그레이션**
   - [ ] 프로젝트의 핵심 공통 컴포넌트부터 순차적 업데이트
   - [ ] 각 컴포넌트별 테스트 케이스 작성 및 실행
   - [ ] 반응형 동작 확인

4. **검증 및 배포**
   - [ ] 스테이징 환경에서 통합 테스트
   - [ ] 성능 영향 측정 (번들 크기, 페이지 로드 시간)
   - [ ] 점진적 배포 및 모니터링

> **참고**: 이 체크리스트는 일반적인 지침이며, 프로젝트의 규모, 팀 구성, 우선순위에 따라 조정해야 합니다.


## 7. 추가 고려사항

### 7.1 번들 크기 최적화

새 디자인 시스템 추가로 인한 CSS와 JavaScript 번들 크기 증가에 주의합니다.

```js
// 참고용 예시 - 프로젝트의 Tailwind 설정에 맞게 수정 필요
// tailwind.config.js에서 미사용 스타일 제거
module.exports = {
  // 프로젝트에 맞는 purge/content 설정
  content: [
    './src/**/*.{js,jsx,ts,tsx}',
    // 프로젝트 구조에 맞게 경로 조정
  ],
}
```

> **중요**: 위 설정은 Tailwind CSS를 사용하는 프로젝트를 위한 예시입니다. 프로젝트의 실제 빌드 시스템, CSS 처리 방식, 번들러 설정에 맞게 조정해야 합니다.

### 7.2 성능 영향 고려

그라데이션 및 블러 효과가 성능에 미치는 영향을 고려하고 최적화합니다.

```css
/* 참고용 예시 - 프로젝트의 애니메이션 구현 방식에 맞게 수정 필요 */

/* 성능 고려한 애니메이션 */
.animate-gradient {
  /* GPU 가속 활용 */
  transform: translateZ(0);
  will-change: background-position;
  /* 프로젝트의 실제 애니메이션 요구사항에 맞게 조정 */
}

/* 저사양 기기 고려 (media query) */
@media (prefers-reduced-motion: reduce) {
  /* 프로젝트의 애니메이션 클래스에 맞게 조정 */
  .animate-gradient {
    animation: none;
    /* 프로젝트에 맞는 대체 스타일 */
  }
}
```

> **주의**: 애니메이션 최적화는 프로젝트의 실제 성능 요구사항과 대상 사용자의 기기 스펙에 따라 달라질 수 있습니다. 프로젝트 상황에 맞게 최적화 전략을 조정하세요.

### 7.3 브라우저 호환성

최신 CSS 기능의 브라우저 호환성을 확인하고 필요시 대체 스타일을 제공합니다.

```css
/* 참고용 예시 - 프로젝트의 브라우저 지원 범위에 맞게 수정 필요 */

/* backdrop-filter에 대한 대체 스타일 */
.glass-effect {
  /* 프로젝트에서 실제로 사용할 유리 효과 스타일로 대체 */
  
  /* 대체 스타일 - 프로젝트의 브라우저 지원 범위에 맞게 조정 */
  @supports not (backdrop-filter: blur(12px)) {
    /* 대체 스타일 정의 */
  }
}
```

> **참고**: 프로젝트의 브라우저 지원 정책과 대상 사용자의 브라우저 통계에 따라 호환성 전략을 수립해야 합니다. Can I Use(https://caniuse.com/)와 같은 도구를 활용하여 CSS 기능의 브라우저 지원 현황을 확인하세요.
```

## 8. 결론

기존 프로젝트에 새 디자인 시스템을 적용할 때는 점진적인 접근 방식이 중요합니다. 기존 코드의 호환성을 유지하면서 새로운 디자인을 도입하는 것이 핵심입니다.

### 중요 권장사항

1. **프로젝트별 맞춤화**
   - 이 가이드에서 제공하는 모든 코드 예시는 참고용일 뿐입니다
   - 실제 구현 시에는 프로젝트의 특성, 구조, 컨벤션에 맞게 조정해야 합니다
   - 프로젝트의 기존 코드를 철저히 분석한 후 마이그레이션 계획을 수립하세요

2. **단계적 접근**
   - 한 번에 모든 것을 변경하려 하지 말고, 가장 중요하고 자주 사용되는 컴포넌트부터 시작하세요
   - 각 변경 사항이 기존 기능에 미치는 영향을 철저히 테스트하세요
   - 새 페이지 또는 신규 기능에 먼저 적용한 후, 기존 페이지로 확장하세요

3. **팀 협업**
   - 디자인 시스템 변경은 팀 전체의 이해와 협력이 필요합니다
   - 개발자, 디자이너, QA 팀 간의 원활한 커뮤니케이션을 유지하세요
   - 마이그레이션 계획과 진행 상황을 모든 이해관계자와 공유하세요

4. **문서화 중요성**
   - 변경된 컴포넌트, API, 스타일에 대한 명확한 문서를 제공하세요
   - 사용 예시, 마이그레이션 가이드, 주의사항을 포함한 내부 개발자 문서를 작성하세요
   - 새로운 디자인 시스템에 대한 교육과 워크숍을 고려하세요

이 가이드를 출발점으로 삼아, 각 프로젝트의 고유한 상황과 요구사항에 맞게 마이그레이션 전략을 수립하시기 바랍니다. 디자인 시스템의 변경은 도전적일 수 있지만, 체계적인 접근과 철저한 계획을 통해 리스크를 최소화하면서 성공적으로 구현할 수 있습니다.

마이그레이션은 코드 변경뿐만 아니라 개발팀 전체의 워크플로우에 영향을 미치는 과정임을 항상 기억하세요. 궁극적으로 더 일관되고 효율적인 개발 경험과 향상된 사용자 경험을 제공하는 것이 디자인 시스템 마이그레이션의 목표입니다.