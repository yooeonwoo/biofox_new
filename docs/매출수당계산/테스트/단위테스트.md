# 매출수당계산 단위 테스트 계획

## 1. 개요

이 문서는 매출수당계산 시스템의 단위 테스트 계획에 대해 설명합니다. 단위 테스트는 개별 함수, 컴포넌트, API 엔드포인트가 예상대로 동작하는지 확인하기 위한 테스트입니다.

## 2. 테스트 환경

- 테스트 프레임워크: Jest
- 테스트 라이브러리: React Testing Library (프론트엔드), Supertest (API)
- 모킹 라이브러리: MSW (Mock Service Worker)
- 커버리지 측정: Jest의 `--coverage` 옵션

## 3. 테스트 대상 및 방법

### 3.1 유틸리티 함수 테스트

#### 매출 및 수당 계산 함수 테스트

- 테스트 대상: `/lib/commission.ts`의 계산 함수들
- 테스트 방법: 입력값에 따른 출력값 검증
- 테스트 케이스:

```typescript
// __tests__/unit/lib/commission.test.ts
import { 
  calculateProductCommission, 
  calculateDeviceCommission, 
  calculateSubKolCommission,
  calculateMonthlySales
} from '@/lib/commission';

describe('Commission Calculation Functions', () => {
  // 제품 수당 계산 테스트 (매출의 30%)
  test('calculateProductCommission should return 30% of sales', () => {
    expect(calculateProductCommission(100000)).toBe(30000);
    expect(calculateProductCommission(0)).toBe(0);
    expect(calculateProductCommission(333333)).toBe(99999.9);
  });

  // 기기 수당 계산 테스트 (마이크로젯만 해당)
  test('calculateDeviceCommission should return correct commission based on cumulative device count', () => {
    // 누적 4대 이하: 1대당 1,500,000원
    expect(calculateDeviceCommission(1, 1)).toBe(1500000); // 첫 대
    expect(calculateDeviceCommission(2, 3)).toBe(3000000); // 누적 3대일 때 2대 추가 주문
    expect(calculateDeviceCommission(1, 4)).toBe(1500000); // 누적 4대일 때 1대 추가 주문
    
    // 누적 5대 이상: 1대당 2,500,000원
    expect(calculateDeviceCommission(1, 5)).toBe(2500000); // 누적 5대일 때 1대 추가 주문
    expect(calculateDeviceCommission(3, 7)).toBe(7500000); // 누적 7대일 때 3대 추가 주문
  });

  // 하위 KOL 첫 달 수당 계산 테스트 (매출의 10%)
  test('calculateSubKolCommission should return 10% of sub KOL first month total sales', () => {
    expect(calculateSubKolCommission(100000)).toBe(10000);
    expect(calculateSubKolCommission(0)).toBe(0);
    expect(calculateSubKolCommission(500000)).toBe(50000);
  });
  
  // 월별 매출 및 수당 합산 테스트
  test('calculateMonthlySales should aggregate sales and commissions', () => {
    const orders = [
      { productSales: 100000, deviceSales: 0, commission: 30000 },
      { productSales: 200000, deviceSales: 149000, commission: 60000 + 1500000 }
    ];
    
    const result = calculateMonthlySales(orders);
    expect(result.productSales).toBe(300000);
    expect(result.deviceSales).toBe(149000);
    expect(result.totalSales).toBe(449000);
    expect(result.commission).toBe(1590000);
  });
});
```

#### 날짜 및 데이터 가공 유틸리티 테스트

- 테스트 대상: `/lib/utils.ts`의 유틸리티 함수들
- 테스트 방법: 입력값에 따른 출력값 검증
- 테스트 케이스:

```typescript
// __tests__/unit/lib/utils.test.ts
import { 
  formatYearMonth, 
  getPreviousYearMonth, 
  calculateGrowthRate,
  aggregateProductSalesRatios
} from '@/lib/utils';

describe('Utility Functions', () => {
  // 연월 포맷팅 테스트
  test('formatYearMonth should format date to YYYY-MM', () => {
    const date = new Date('2023-08-15');
    expect(formatYearMonth(date)).toBe('2023-08');
  });

  // 이전 월 계산 테스트
  test('getPreviousYearMonth should return previous month', () => {
    expect(getPreviousYearMonth('2023-08')).toBe('2023-07');
    expect(getPreviousYearMonth('2023-01')).toBe('2022-12');
  });

  // 성장률 계산 테스트
  test('calculateGrowthRate should calculate growth percentage', () => {
    expect(calculateGrowthRate(100, 80)).toBe(25); // 25% 증가
    expect(calculateGrowthRate(80, 100)).toBe(-20); // 20% 감소
    expect(calculateGrowthRate(100, 100)).toBe(0); // 변화 없음
    expect(calculateGrowthRate(100, 0)).toBe(100); // 첫 매출
    expect(calculateGrowthRate(0, 0)).toBe(0); // 둘 다 0
  });

  // 제품별 매출 비율 계산 테스트
  test('aggregateProductSalesRatios should calculate ratios correctly', () => {
    const sales = [
      { productId: 1, salesAmount: 50000 },
      { productId: 2, salesAmount: 150000 }
    ];
    
    const result = aggregateProductSalesRatios(sales);
    expect(result).toEqual([
      { productId: 1, salesAmount: 50000, salesRatio: 0.25 },
      { productId: 2, salesAmount: 150000, salesRatio: 0.75 }
    ]);
    
    // 총합이 0인 경우
    expect(aggregateProductSalesRatios([])).toEqual([]);
    expect(aggregateProductSalesRatios([
      { productId: 1, salesAmount: 0 },
      { productId: 2, salesAmount: 0 }
    ])).toEqual([
      { productId: 1, salesAmount: 0, salesRatio: 0 },
      { productId: 2, salesAmount: 0, salesRatio: 0 }
    ]);
  });
});
```

### 3.2 API 엔드포인트 테스트

#### 매출 요약 API 테스트

- 테스트 대상: `/api/sales/monthly-summary`
- 테스트 방법: API 호출 시뮬레이션 및 응답 검증
- 테스트 케이스:

```typescript
// __tests__/unit/api/monthly-summary.test.ts
import { createMocks } from 'node-mocks-http';
import monthlySummaryHandler from '@/app/api/sales/monthly-summary/route';
import { db } from '@/db';

// Drizzle ORM 모킹
jest.mock('@/db', () => ({
  db: {
    query: jest.fn(),
    select: jest.fn().mockReturnThis(),
    from: jest.fn().mockReturnThis(),
    where: jest.fn().mockReturnThis(),
    execute: jest.fn()
  }
}));

describe('Monthly Summary API', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('should return 400 if kolId is missing', async () => {
    const { req, res } = createMocks({
      method: 'GET',
      query: {}
    });

    await monthlySummaryHandler(req, res);
    expect(res.statusCode).toBe(400);
    expect(JSON.parse(res._getData())).toEqual({
      success: false,
      error: { code: 'INVALID_PARAMS', message: expect.any(String) }
    });
  });

  test('should return monthly summary data for valid kolId', async () => {
    const mockSummaryData = {
      kolId: 1,
      yearMonth: '2023-08',
      monthlySales: 5000000,
      monthlyCommission: 1500000,
      avgMonthlySales: 4500000,
      cumulativeCommission: 10000000,
      previousMonthSales: 4000000,
      previousMonthCommission: 1200000,
      activeShopsCount: 5,
      totalShopsCount: 8
    };

    // 데이터베이스 쿼리 결과 모킹
    db.execute.mockResolvedValue([mockSummaryData]);

    const { req, res } = createMocks({
      method: 'GET',
      query: { kolId: '1', yearMonth: '2023-08' }
    });

    await monthlySummaryHandler(req, res);
    expect(res.statusCode).toBe(200);
    expect(JSON.parse(res._getData())).toEqual({
      success: true,
      data: mockSummaryData
    });
  });

  test('should handle database errors gracefully', async () => {
    // 데이터베이스 오류 모킹
    db.execute.mockRejectedValue(new Error('Database error'));

    const { req, res } = createMocks({
      method: 'GET',
      query: { kolId: '1' }
    });

    await monthlySummaryHandler(req, res);
    expect(res.statusCode).toBe(500);
    expect(JSON.parse(res._getData())).toEqual({
      success: false,
      error: { code: 'INTERNAL_ERROR', message: expect.any(String) }
    });
  });
});
```

#### 주문 처리 및 수당 계산 API 테스트

- 테스트 대상: `/api/sales/register`
- 테스트 방법: API 호출 시뮬레이션 및 DB 작업 검증
- 테스트 케이스:

```typescript
// __tests__/unit/api/register.test.ts
import { createMocks } from 'node-mocks-http';
import registerHandler from '@/app/api/sales/register/route';
import { db } from '@/db';
import * as commissionUtils from '@/lib/commission';

// DB와 유틸리티 함수 모킹
jest.mock('@/db', () => ({
  db: {
    transaction: jest.fn((callback) => callback()),
    insert: jest.fn().mockReturnThis(),
    values: jest.fn().mockReturnThis(),
    returning: jest.fn().mockReturnThis(),
    execute: jest.fn(),
    select: jest.fn().mockReturnThis(),
    from: jest.fn().mockReturnThis(),
    where: jest.fn().mockReturnThis()
  }
}));

jest.mock('@/lib/commission', () => ({
  calculateProductCommission: jest.fn().mockReturnValue(30000),
  calculateDeviceCommission: jest.fn().mockReturnValue(1500000),
  processOrderForSalesCalculation: jest.fn()
}));

describe('Sales Register API', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('should process new order and calculate commissions', async () => {
    // 모킹된 주문 데이터
    const mockOrder = {
      id: 123,
      shopId: 1,
      totalAmount: 100000,
      orderDate: new Date('2023-08-15')
    };
    
    // 모킹된 주문 아이템
    const mockOrderItems = [
      { productId: 1, quantity: 1, price: 74800, isDevice: false },
      { productId: 2, quantity: 1, price: 77000, isDevice: false }
    ];
    
    // DB 쿼리 결과 모킹
    db.execute.mockResolvedValueOnce([mockOrder]); // 주문 조회
    db.execute.mockResolvedValueOnce(mockOrderItems); // 주문 아이템 조회
    db.execute.mockResolvedValueOnce([{ id: 1 }]); // KOL ID 조회
    
    const { req, res } = createMocks({
      method: 'POST',
      body: {
        orderId: 123,
        processingType: 'new'
      }
    });

    await registerHandler(req, res);
    
    // 주문 정보 조회 여부 확인
    expect(db.select).toHaveBeenCalled();
    expect(db.where).toHaveBeenCalledWith('id = ?', 123);
    
    // 수당 계산 함수 호출 여부 확인
    expect(commissionUtils.processOrderForSalesCalculation).toHaveBeenCalled();
    
    // 응답 상태 확인
    expect(res.statusCode).toBe(200);
    expect(JSON.parse(res._getData())).toEqual({
      success: true,
      data: { message: expect.any(String) }
    });
  });

  // 추가 테스트 케이스...
});
```

### 3.3 프론트엔드 컴포넌트 테스트

#### 공통 컴포넌트 테스트 (월 선택기)

- 테스트 대상: `/components/dashboard/MonthSelector.tsx`
- 테스트 방법: 렌더링 및 사용자 상호작용 테스트
- 테스트 케이스:

```typescript
// __tests__/unit/components/MonthSelector.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { MonthSelector } from '@/components/dashboard/MonthSelector';

describe('MonthSelector Component', () => {
  const mockOnChange = jest.fn();
  
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders current month by default', () => {
    const currentDate = new Date();
    const currentYearMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
    
    render(<MonthSelector onChange={mockOnChange} />);
    expect(screen.getByDisplayValue(currentYearMonth)).toBeInTheDocument();
  });

  test('allows selecting a different month', () => {
    render(<MonthSelector onChange={mockOnChange} />);
    
    const select = screen.getByRole('combobox');
    fireEvent.change(select, { target: { value: '2023-07' } });
    
    expect(mockOnChange).toHaveBeenCalledWith('2023-07');
  });

  test('limits selection to last 24 months', () => {
    render(<MonthSelector onChange={mockOnChange} />);
    
    const options = screen.getAllByRole('option');
    expect(options.length).toBeLessThanOrEqual(24);
  });

  test('accepts an initial value prop', () => {
    render(<MonthSelector onChange={mockOnChange} value="2023-05" />);
    expect(screen.getByDisplayValue('2023-05')).toBeInTheDocument();
  });
});
```

#### 데이터 시각화 컴포넌트 테스트 (매출 비율 차트)

- 테스트 대상: `/components/dashboard/ProductRatioChart.tsx`
- 테스트 방법: 렌더링 및 데이터 표시 테스트
- 테스트 케이스:

```typescript
// __tests__/unit/components/ProductRatioChart.test.tsx
import { render, screen } from '@testing-library/react';
import { ProductRatioChart } from '@/components/dashboard/ProductRatioChart';

// Recharts 모킹 (SVG 렌더링 문제 방지)
jest.mock('recharts', () => {
  const OriginalModule = jest.requireActual('recharts');
  return {
    ...OriginalModule,
    ResponsiveContainer: ({ children }) => children,
    PieChart: ({ children }) => <div data-testid="pie-chart">{children}</div>,
    Pie: ({ data }) => <div data-testid="pie">{JSON.stringify(data)}</div>,
    Tooltip: () => <div data-testid="tooltip" />,
    Legend: () => <div data-testid="legend" />
  };
});

describe('ProductRatioChart Component', () => {
  const mockData = [
    { productId: 1, productName: '큐어부스터', salesAmount: 500000, salesRatio: 0.25 },
    { productId: 2, productName: '올인원세럼', salesAmount: 750000, salesRatio: 0.375 },
    { productId: 3, productName: 'V앰플', salesAmount: 750000, salesRatio: 0.375 }
  ];

  test('renders chart with provided data', () => {
    render(<ProductRatioChart data={mockData} />);
    
    expect(screen.getByTestId('pie-chart')).toBeInTheDocument();
    expect(screen.getByTestId('pie')).toBeInTheDocument();
    expect(screen.getByTestId('tooltip')).toBeInTheDocument();
    expect(screen.getByTestId('legend')).toBeInTheDocument();
    
    // 데이터가 차트에 전달되었는지 확인
    const pieElement = screen.getByTestId('pie');
    const renderedData = JSON.parse(pieElement.textContent || '[]');
    expect(renderedData.length).toBe(3);
    expect(renderedData[0].name).toBe('큐어부스터');
    expect(renderedData[1].name).toBe('올인원세럼');
    expect(renderedData[2].name).toBe('V앰플');
  });

  test('renders empty state when no data provided', () => {
    render(<ProductRatioChart data={[]} />);
    expect(screen.getByText(/데이터가 없습니다/i)).toBeInTheDocument();
  });

  test('formats currency values correctly', () => {
    render(<ProductRatioChart data={mockData} />);
    
    // 금액 포맷팅 테스트는 도구 팁에 대한 직접 테스트가 어려워
    // 내부 함수가 올바르게 호출되는지 테스트하는 형태로 변경할 수 있음
  });
});
```

## 4. 테스트 커버리지 목표

- 유틸리티 함수: 95% 이상 (라인 및 브랜치)
- API 엔드포인트: 90% 이상 (라인 및 브랜치)
- 프론트엔드 컴포넌트: 85% 이상 (라인)

## 5. 테스트 실행 방법

### 5.1 전체 단위 테스트 실행

```bash
npm run test
```

### 5.2 특정 영역 테스트 실행

```bash
# 유틸리티 함수 테스트
npm run test:unit lib

# API 엔드포인트 테스트
npm run test:unit api

# 컴포넌트 테스트
npm run test:unit components
```

### 5.3 커버리지 측정

```bash
npm run test -- --coverage
```

## 6. 테스트 파일 구조

```
__tests__/
├── unit/
│   ├── lib/
│   │   ├── commission.test.ts
│   │   └── utils.test.ts
│   ├── api/
│   │   ├── monthly-summary.test.ts
│   │   ├── product-ratios.test.ts
│   │   ├── shop-ranking.test.ts
│   │   ├── shop-details.test.ts
│   │   └── register.test.ts
│   └── components/
│       ├── MonthSelector.test.tsx
│       ├── SummaryCard.test.tsx
│       ├── ProductRatioChart.test.tsx
│       └── ShopRankingTable.test.tsx
└── integration/
    └── ... (통합 테스트 파일)
```

## 7. 테스트 우선순위

1. 매출 및 수당 계산 유틸리티 함수 (핵심 비즈니스 로직)
2. 주문 처리 및 매출/수당 계산 API (`/api/sales/register`)
3. 매출 요약 API (`/api/sales/monthly-summary`)
4. 공통 컴포넌트 및 데이터 시각화 컴포넌트 