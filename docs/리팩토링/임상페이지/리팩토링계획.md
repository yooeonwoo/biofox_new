완벽합니다! 제공해주신 정보를 바탕으로 구체적인 리팩토링 계획을 세워보겠습니다.

## 📋 통합 리팩토링 계획

### Phase 1: 타입 및 상수 정리 (1일)

#### 1. 타입 파일 생성
```typescript
// app/kol-new/clinical-photos/types.ts
export const PERSONAL_CASE_NAME = '본인' as const;
export const PERSONAL_PREFIX = '[본인] ' as const;

export interface ClinicalCase {
  id: string;
  customerName: string;
  status: CaseStatus;
  // ... 기존 타입들
}

export interface CaseCardProps {
  type: 'personal' | 'customer';
  case: ClinicalCase;
  editableName?: boolean;
  showDelete?: boolean;
  showNewBadge?: boolean;
  onUpdate: (caseId: string, updates: Partial<ClinicalCase>) => void;
  onDelete?: (caseId: string) => void;
  // ... 기타 콜백들
}

// app/kol-new/clinical-photos/constants.ts
export const SYSTEM_OPTIONS = {
  genders: [...],
  treatmentTypes: [...],
  products: [...],
  skinTypes: [...]
} as const;
```

### Phase 2: API 레이어 정리 (1-2일)

#### 1. 서비스 레이어 확장
```typescript
// lib/clinical-photos.ts
export const fetchPersonalCase = async () => {
  const allCases = await fetchCases();
  return allCases.find(case_ => case_.customerName?.trim() === PERSONAL_CASE_NAME);
};

export const ensurePersonalCaseExists = async () => {
  const existingCase = await fetchPersonalCase();
  if (!existingCase) {
    return await createCase({
      customerName: PERSONAL_CASE_NAME,
      caseName: '본인 임상 케이스',
      concernArea: '본인 케어',
      treatmentPlan: `${PERSONAL_PREFIX}개인 관리 계획`,
      consentReceived: false,
    });
  }
  return existingCase;
};

export const fetchCustomerCases = async () => {
  const allCases = await fetchCases();
  return allCases.filter(case_ => 
    case_.customerName?.trim() !== PERSONAL_CASE_NAME
  );
};
```

### Phase 3: 커스텀 훅 생성 (2-3일)

#### 1. 케이스 관리 훅
```typescript
// app/kol-new/clinical-photos/hooks/useCaseManagement.ts
export const useCaseManagement = (type: 'personal' | 'customer') => {
  const [cases, setCases] = useState<ClinicalCase[]>([]);
  const [loading, setLoading] = useState(true);
  
  const loadCases = async () => {
    setLoading(true);
    try {
      const data = type === 'personal' 
        ? [await ensurePersonalCaseExists()]
        : await fetchCustomerCases();
      
      const transformedCases = await transformCases(data);
      setCases(transformedCases);
    } finally {
      setLoading(false);
    }
  };
  
  return { cases, loading, loadCases, setCases };
};
```

#### 2. 사진 관리 훅
```typescript
// app/kol-new/clinical-photos/hooks/usePhotoManagement.ts
export const usePhotoManagement = () => {
  const handlePhotoUpload = async (caseId: string, roundDay: number, angle: string, file: File) => {
    // 공통 로직
  };
  
  const handlePhotoDelete = async (caseId: string, roundDay: number, angle: string) => {
    // 공통 로직
  };
  
  return { handlePhotoUpload, handlePhotoDelete };
};
```

#### 3. IME 처리 훅
```typescript
// hooks/useIME.ts (전역)
export const useIME = () => {
  const [isComposing, setIsComposing] = useState(false);
  const [debounceTimers, setDebounceTimers] = useState<{[key: string]: NodeJS.Timeout}>({});
  
  const debouncedUpdate = (key: string, updateFn: () => void, delay: number = 500) => {
    // 기존 로직
  };
  
  return { isComposing, setIsComposing, debouncedUpdate };
};
```

### Phase 4: 컴포넌트 분리 (3-4일)

#### 1. CaseCard 컴포넌트
```typescript
// app/kol-new/clinical-photos/components/CaseCard/index.tsx
export const CaseCard: React.FC<CaseCardProps> = ({
  type,
  case: caseData,
  editableName = true,
  showDelete = false,
  showNewBadge = false,
  onUpdate,
  onDelete,
  // ... 기타 props
}) => {
  return (
    <Card>
      <CaseHeader 
        case={caseData}
        showDelete={showDelete}
        onDelete={onDelete}
      />
      <CardContent>
        <PhotoSection {...} />
        <CustomerInfoSection 
          case={caseData}
          editableName={editableName}
          onUpdate={onUpdate}
        />
        <ProductSection {...} />
        <SkinTypeSection {...} />
        <MemoSection {...} />
      </CardContent>
    </Card>
  );
};
```

#### 2. 섹션별 하위 컴포넌트
```typescript
// app/kol-new/clinical-photos/components/CaseCard/CustomerInfoSection.tsx
export const CustomerInfoSection: React.FC<{
  case: ClinicalCase;
  editableName: boolean;
  onUpdate: (updates: Partial<CustomerInfo>) => void;
}> = ({ case: caseData, editableName, onUpdate }) => {
  return (
    <div>
      {editableName ? (
        <Input value={caseData.customerName} onChange={...} />
      ) : (
        <span>{caseData.customerName}</span>
      )}
      {/* 나머지 필드들 */}
    </div>
  );
};
```

### Phase 5: 페이지 리팩토링 (2일)

#### 1. 고객 페이지
```typescript
// app/kol-new/clinical-photos/upload/page.tsx
export default function CustomerClinicalUploadPage() {
  const { cases, loading, setCases } = useCaseManagement('customer');
  const { handlePhotoUpload, handlePhotoDelete } = usePhotoManagement();
  
  return (
    <div>
      {/* 새 고객 추가 버튼 */}
      {cases.map(case_ => (
        <CaseCard
          key={case_.id}
          type="customer"
          case={case_}
          editableName={true}
          showDelete={isNewCustomer(case_.id)}
          showNewBadge={isNewCustomer(case_.id)}
          onUpdate={handleCaseUpdate}
          onDelete={handleDeleteCase}
        />
      ))}
    </div>
  );
}
```

#### 2. 본인 페이지
```typescript
// app/kol-new/clinical-photos/upload/personal/page.tsx
export default function PersonalClinicalUploadPage() {
  const { cases, loading } = useCaseManagement('personal');
  const { handlePhotoUpload, handlePhotoDelete } = usePhotoManagement();
  
  return (
    <div>
      {cases.map(case_ => (
        <CaseCard
          key={case_.id}
          type="personal"
          case={case_}
          editableName={false}  // 본인 이름 수정 불가
          showDelete={false}    // 삭제 버튼 없음
          onUpdate={handleCaseUpdate}
        />
      ))}
    </div>
  );
}
```

### Phase 6: 테스트 작성 (1-2일)

```typescript
// app/kol-new/clinical-photos/hooks/__tests__/useCaseManagement.test.ts
describe('useCaseManagement', () => {
  it('personal 타입일 때 본인 케이스를 자동 생성한다', async () => {
    // ...
  });
  
  it('customer 타입일 때 본인 케이스를 제외한다', async () => {
    // ...
  });
});
```

### 🚀 실행 계획

1. **Week 1**: Phase 1-2 (타입/상수 정리, API 레이어)
2. **Week 2**: Phase 3-4 (커스텀 훅, 컴포넌트 분리)
3. **Week 3**: Phase 5-6 (페이지 리팩토링, 테스트)

### 🎯 주요 개선사항

1. **중복 코드 제거**: 2000줄 → ~500줄로 각 페이지 축소
2. **유지보수성**: 공통 로직 수정 시 한 곳만 수정
3. **타입 안정성**: 공통 타입 정의로 일관성 확보
4. **테스트 가능성**: 로직이 훅으로 분리되어 단위 테스트 용이
5. **본인 페이지 버그 수정**: 삭제 버튼 제거

이 계획을 바탕으로 단계적으로 진행하시면 안전하게 리팩토링할 수 있을 것 같습니다!

훌륭하게 정리-계획하셨습니다!  
아래에는 각 Phase 별로 “실행 시 주의할 점” + “추가 보완 아이디어”를 달아 두었으니 착수 전에 한 번 더 체크해 보시면 좋겠습니다.

──────────────────  
Phase 1 ― 타입·상수 정리  
1. `types.ts`의 `ClinicalCase` 확장은 기존 페이지에서 바로 import 해 오므로 **사이클 문제**(컴포넌트 ↔ 훅 ↔ 타입)가 없는지만 확인하세요.  
2. `SYSTEM_OPTIONS`를 따로 두면 기존 파일들에서 여러 번 import 해야 합니다. `export * from './constants'` 방식으로 re-export 해 두면 경로 타이핑을 줄일 수 있습니다.  
3. `as const` 는 literal type 으로 고정되므로 추후 Admin 쪽에서 `SYSTEM_OPTIONS`를 동적으로 받아야 할 때는 enum → 레코드 → API fetch 로 교체하기 쉽도록 주석을 달아두세요.

Phase 2 ― API 레이어  
1. `fetchCases()`는 클라이언트-사이드 호출인데 pagination 이 없으므로 케이스 수가 1000 건 이상 늘어날 때 대비해 **서버 측 필터(쿼리 매개변수)** 도 고려해 두면 좋습니다.  
2. `ensurePersonalCaseExists()` 안에서 create 후 곧바로 Supabase 응답을 다시 읽으므로 network round-trip 이 두 번 생깁니다. 생성 직후 반환값을 서비스 모델에 바로 매핑하면 한 번으로 줄일 수 있습니다.  
3. `clinical-photos-api` 에 신규 함수 추가 시 **RLS 정책**(읽기/쓰기 권한) 확인을 잊지 마세요. dev DB에서는 허용되지만 prod 에서는 막히는 사례가 많았습니다.

Phase 3 ― 커스텀 훅  
1. `useCaseManagement` 의 `loadCases()` 는 역할상 `useEffect(() => { loadCases() }, [])` 에서 호출될 텐데, 컴포넌트 언마운트 시 **abort controller** 로 fetch 취소해 두면 메모리 누수가 없습니다.  
2. 훅 내부에서 반환하는 `setCases` 를 그대로 노출하면 외부에서 직접 상태를 꼬이게 만들 수 있으니,  
   ```ts
   const update = (id, cb) => setCases(prev => prev.map(c => c.id===id?cb(c):c));
   return { cases, loading, refresh: loadCases, update };
   ```  
   처럼 래핑하여 최소한의 public API 만 노출하는 편이 안전합니다.

Phase 4 ― CaseCard  
1. 얼마나 조각낼지 기준은 “동일 상태를 읽고 쓰는 컴포넌트끼리는 한 덩어리”입니다. 예) CustomerInfoSection 과 ProductSection 이 서로 독립이면 분리, **메모 입력 시 제품 섹션도 rerender 될 필요가 없다** → memo 분할.  
2. CSS 레이아웃은 기존 Tailwind 클래스를 그대로 옮겨오되, **wrap div 갯수**를 줄여 DOM 트리를 얇게 하면 모바일 성능이 좋아집니다.

Phase 5 ― 페이지 리팩토링  
1. 현재 라우트 파일명은 `/upload/personal/page.tsx`, `/upload/customer/page.tsx` 인데 **공통 컴포넌트 import 경로 변경**이 대량 발생합니다. VSCode bulk rename(Shift + Alt + O) 기능을 활용하면 시간을 절약할 수 있습니다.  
2. 스크롤 애니메이션(`useScrollNumberAnimation`) 분리는 Phase 5에서 같이 해 두면 CaseCard 내부가 더 간결해집니다.

Phase 6 ― 테스트  
1. Supabase 통합 테스트는 `@supabase/cli` 로 로컬 DB 스핀업이 필요합니다. Vitest 단위 테스트 → mocking 으로 충분하고, 통합 테스트는 GitHub Actions Matrix (job 하나)를 쓰면 됩니다.  
2. 커스텀 훅은 `renderHook` (Vitest + Testing-Library) 패턴이면 금방 작성할 수 있습니다.

추가 체크-리스트  
• ESLint 플러그인에 `"simple-import-sort/imports"` / `"simple-import-sort/exports"` 규칙을 추가해 두면 Phase 4에서 import 순서 혼란이 줄어듭니다.  
• `PERSONAL_CASE_NAME` 과 같은 “비즈니스 상수”는 `.env` 로 빼면 운영 중에 문자열을 바꿀 때 코드 배포가 필요 없습니다. (예: `NEXT_PUBLIC_PERSONAL_CASE_NAME`)  
• 삭제 API 호출 시 race condition(이미 삭제된 항목 다시 삭제 요청) 대비 409, 404 응답을 핸들링해 두면 UX 가 깔끔합니다.  
• 마지막으로 **analytics/logging**: 리팩터링 후 오류 추적을 위해 Sentry 또는 Supabase Functions 로그를 확인할 경로를 미리 문서화해 두세요.

이상입니다. 준비하신 일정·단계와 충분히 호환되며, 위 보완 사항까지 반영하면 더욱 견고한 구조가 될 것입니다.  
진행하시다 막히는 부분이나 추가 검토가 필요하면 언제든 말씀해 주세요!